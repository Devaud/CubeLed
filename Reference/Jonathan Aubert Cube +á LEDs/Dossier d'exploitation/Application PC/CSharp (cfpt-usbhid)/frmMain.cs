using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;

using System.IO;                //Pour gestion des fichiers (I/O)
using System.Configuration;     //Pour exploitation d'un fichier de configuration
using System.Collections;       //Pour utilisation des ArrayList

/***************************************************************************************************
 * Pour utilisation de la librairie USB-HID, wrappée via Win32Usb & exploite les dll Windows 
 * setupapi.dll, hid.dll, kernel32.dll, user32.dll. Les concepts d'application restent les mêmes 
 * que pour C++Builder. L'implémentation est cependant simplifée car implémentée au niveau de la 
 * dll UsbLibrary (composant, thread d'éctoute parser etc). 
 * Adjonction de méthodes de récupération Manufacturer, Product, Version + Capability
 * ************************************************************************************************/
using UsbLibraryCfptAdd;

namespace Cubizator
{
    public partial class frmMain : Form
    {
        AboutBox frm_à_propos = new AboutBox();     //création de la boîte de dialogue

        Classcube cubeled;                          //instanciation de la classe du cube
       

        #region Buffer de données

        class DataByte
        {
            //--- Champs ---------------
            private byte[] dataByte;
            
            //--- Constructeurs --------
            public DataByte(params byte[] dataByte)
            {
                this.dataByte = new byte[dataByte.Length];
                dataByte.CopyTo(this.dataByte, 0);
            }

            public DataByte()
            {
                this.dataByte = new byte[1];
            }

            public DataByte(int size)
            {
                this.dataByte = new byte[size];
            }

            public DataByte(int size, byte initValue)
            {
                this.dataByte = new byte[size];

                for (int i = 0; i < size; i++)
                    this.dataByte[i] = initValue;
            }

            //--- Indexeur -----------
            public byte this[int indexe]
            {
                get { return this.dataByte[indexe]; }
                set { this.dataByte[indexe] = value; }
            }

            public int Length()
            {
                return this.dataByte.Length;
            }

            public byte[] ToBytes()
            {
                return this.dataByte;
            }

            //--- Implémentation des méthodes de l'interface IEnumerator ------
            public IEnumerator<double> GetEnumerator()
            {
                foreach (int valeur in this.dataByte) yield return valeur;
            }
        }
        
        #endregion

        UsbHidPort usbPort;
        DataByte bufIn, bufOut;

        string str_mod_pwm = "#pwm$";   //8 images avec un délai d'1s entre chaque
        string str_stop_usb = "#stop$";             //permet de stopper le mode usb!
        string str_start_drawing = "#draw$";              //Indique au cube que le mode dessin est activé!
        string str_cube_rdy = "#ready$";            //trame reçue en cas de bonne connection!
        string str_cube_notrdy = "#notready$";      //trame reçue en cas de mode usb désactivé du côté cube!

        Label[] cb_matrice;      //Référence sur la matrice de checkboxes

        const string frm_name_new = "New";
        const string frm_name_regl = "Réglages";    //Nom pour la fenêtre de nouveau cube/réglages
        string[] str_étages = new string[] { "Etage 0", "Etage 1", "Etage 2", "Etage 3", "Etage 4", "Etage 5", "Etage 6", "Etage 7" };

        int image_sel = 0;  //Variable permettant la selection de l'image à envoyer
        int étage_sel = 0;

        const string str_entête_file = "#cube anim,"; //Entête d'un fichier

        //Caractéristiques de la matrice de sélection led
        const int nb_CBox_ligne = 8;
        const int nb_ligne = 8;
        Color clled_on = Color.Blue;
        Color clled_off = Color.White;



        #region utility méthode DataChange

        /******************************************************************
         * Détermine si les données reçues passées par args à la fonction
         * diffère de celles mémorisée dans le buffer d'entrée BufIn
         * ***************************************************************/
        private bool DataChange(DataRecievedEventArgs args)
        {
            bool change = false;
 
            //Teste si les données reçues diffère des précédentes d'au moins 1 byte
            int ndx = 0;
            foreach (byte byteData in args.data)
            {
                change |= byteData != bufIn[ndx++];
            }

            return change;
        }

        #endregion

        public frmMain()
        {
            InitializeComponent();

            #region Implémentation du port usb

            //Implémentation du composant usb
            usbPort = new UsbHidPort();

            //Implémentation des procédures événementielles de connexion-déconnexion
            usbPort.OnDeviceArrived += new EventHandler(usbPort_OnDeviceArrived);
            usbPort.OnSpecifiedDeviceArrived +=new EventHandler(usbPort_OnSpecifiedDeviceArrived);
            usbPort.OnDeviceRemoved +=new EventHandler(usbPort_OnDeviceRemoved);
            usbPort.OnSpecifiedDeviceRemoved+=new EventHandler(usbPort_OnSpecifiedDeviceRemoved);

            //Implémentation des procédures événementielles de transmission
            usbPort.OnDataRecieved += new DataRecievedEventHandler(usbPort_OnDataRecieved);
            usbPort.OnDataSend+=new EventHandler(usbPort_OnDataSend);

            #endregion
        }

        #region Définition du device


        private void CBox_changed(object sender, MouseEventArgs e)
        {
            int n_led = byte.Parse((sender as Label).Name);                 //n° de la led dans l'étage (de 0 à 63)
            int ligne = n_led / 8;                                          //ligne
            int bit_ligne = (byte)(7 - (n_led % 8));                        //bit de la ligne

                if (Control.MouseButtons == MouseButtons.Left)    //Si clic gauche de la souris
                {

                    (sender as Label).BackColor = clled_on;   //le label change de couleur  (on)

                    cubeled.datacube[ligne, étage_sel, image_sel] |= (byte)(0x01 << bit_ligne);   //mise à 1 de la led en mémoire

                }
                else if (Control.MouseButtons == MouseButtons.Right)
                {
                    (sender as Label).BackColor = clled_off;    //le label change de couleur (off)
                    cubeled.datacube[ligne, étage_sel, image_sel] &= (byte)~(0x01 << bit_ligne);   //Extinction led en mémoire
                }
                if ((btn_stop_usb.Enabled) && (act_draw.Checked)) //Si le cube est prêt à recevoir des données, et que mode dessin activé    
                {
                    send_command(str_start_drawing);    //Envoi d'une commande de mode dessin!
                    //envoi de l'image sélectionnée au cube via usb
                    send_image_n(image_sel);
                }
        }



        private void frmMain_Load(object sender, EventArgs e)
        {
            try
            {
                //Récupération du VID & PID du fichier de configuration
                string vid_str = ConfigurationManager.AppSettings["VID"];
                string pid_str = ConfigurationManager.AppSettings["PID"];

                //Supprime le 0x...
                vid_str = vid_str.Substring(2);
                pid_str = pid_str.Substring(2);

                usbPort.VendorId = Int32.Parse(vid_str, System.Globalization.NumberStyles.HexNumber);
                usbPort.ProductId = Int32.Parse(pid_str, System.Globalization.NumberStyles.HexNumber);

                //Signalisation de l'état de la connexion
                tssEtat.Text = "Périphérique VID 0x" + usbPort.VendorId.ToString("X4") +
                                         " / PID 0x" + usbPort.ProductId.ToString("X4") +
                                         ": Attente de connexion";

                //Test si le device est déjà connecté au démarrage de l'application
                usbPort.CheckDevicePresent();
            }
            catch (Exception err)
            {
                MessageBox.Show(err.Message, "Configuration VID/PID", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }

        }

        #endregion

        #region Instanciation & Traitement des messages Windows

        protected override void OnHandleCreated(EventArgs e)
        {
            base.OnHandleCreated(e);
            usbPort.RegisterHandle(Handle);
        }

        protected override void WndProc(ref Message msg)
        {
            //Récupère le type de message si de type WM_DEVICECHANGE
            usbPort.ParseMessages(ref msg);

            //Dispatching des messages Windows (idem C++Builder)
            //DEVICE_ARRIVAL & DEVICE_REMOVECOMPLETE
            base.WndProc(ref msg);
        }

        #endregion

        #region Connexion-Déconnexion du device

        /***************************************************************************
         * Fonction événementielle de réception des données exécutée dans un thread.
         * Est déclenchée chaque fois qu'un device usb hid est connecté
         * *************************************************************************/
        private void usbPort_OnDeviceArrived(object sender, EventArgs args)
        {
           //Sur connexion de n'importe quel device
        }

        /***************************************************************************
         * Fonction événementielle de réception des données exécutée dans un thread.
         * Est déclenchée chaque fois qu'un device usb hid défini est connecté
         * *************************************************************************/
        private void usbPort_OnSpecifiedDeviceArrived(object sender, EventArgs args)
        {                     
            //Sur connexion du device défini dans le fichier de configuration
            //Création des buffers
            bufIn = new DataByte(usbPort.SpecifiedDevice.InputReportLength, 0);
            bufOut = new DataByte(usbPort.SpecifiedDevice.OutputReportLength, 0);

            //Signalisation de l'état de la connexion (facultatif)
            tssEtat.Text = "Périphérique VID 0x" + usbPort.VendorId.ToString("X4") +
                                     " / PID 0x" + usbPort.ProductId.ToString("X4") +
                                     ": Connecté";
        }

        /***************************************************************************
         * Fonction événementielle de réception des données exécutée dans un thread.
         * Est déclenchée chaque fois qu'un device usb hid est déconnecté
         * *************************************************************************/
        private void usbPort_OnDeviceRemoved(object sender, EventArgs args)
        {
            

            //Si méthode appelée depuis un autre thread Invocation requise
            if (InvokeRequired)
            {
                //Rappel de la méthode de manière asynchrone
                Invoke(new EventHandler(usbPort_OnDeviceRemoved),
                       new object[] { sender, args });
            }
            else
            {
  
            }
      
        }

        /***************************************************************************
         * Fonction événementielle de réception des données exécutée dans un thread.
         * Est déclenchée chaque fois qu'un device usb hid défini est déconnecté
         * *************************************************************************/
        private void usbPort_OnSpecifiedDeviceRemoved(object sender, EventArgs args)
        {
            //Si méthode appelée depuis un autre thread Invocation requise
            if (InvokeRequired)
            {
                //Rappel de la méthode de manière asynchrone
                Invoke(new EventHandler(usbPort_OnSpecifiedDeviceRemoved),
                       new object[] { sender, args });
            }
            else
            {
                //Sur déconnexion du device défini dans le fichier de configuration
                todo_in_stop_cube();    //Actions à réaliser pour stopper le fonctionnement actuel
                //Libère les buffers
                bufIn = null;
                bufOut = null;

                //Signalisation de l'état de la connexion (facultatif)
                tssEtat.Text = "Périphérique VID 0x" + usbPort.VendorId.ToString("X4") +
                                         " / PID 0x" + usbPort.ProductId.ToString("X4") +
                                         ": Attente de connexion";
            }        
        }

        #endregion

        #region Communication avec le device

        /***************************************************************************
         * Fonction événementielle de réception des données exécutée dans un thread.
         * Est déclenchée chaque fois que des données sont disponibles
         * *************************************************************************/
        private void usbPort_OnDataRecieved(object sender, DataRecievedEventArgs args)
        { 
            //Si méthode appelée depuis un autre thread Invocation requise
            if (InvokeRequired)
            {
                try
                {
                    //Rappel de la méthode de manière asynchrone
                    Invoke(new DataRecievedEventHandler(usbPort_OnDataRecieved),
                           new object[] { sender, args });
                }
                catch(Exception err)
                {
                    MessageBox.Show(err.Message, "Réception de donnée", 
                                    MessageBoxButtons.OK, MessageBoxIcon.Warning);               
                }
            }
            else
            {
                //Déclaration d'un buffer de données local (facultatif)
                byte[] bdata = new byte[usbPort.SpecifiedDevice.InputReportLength];

                //Actualise le buffer de données BufIn si changement
                if (DataChange(args))
                {             
                    //Affichage des données reçues
                    int pos = 0;
                    string str_rec = "";
                    foreach (byte byteData in args.data)
                    {
                        bufIn[pos++] = byteData;    //copie des données dans le bufIn
                    }


                    byte[] toto = new byte[65]; //Copie dans un tableau de bytes

                    for (int j = 0;j<65;j++)
                    {
                        toto[j] = bufIn[j];
                    }

                    str_rec = new string(System.Text.UTF8Encoding.UTF8.GetChars(toto)); //Conversion du tableau en ASCII UTF8


                    if (str_rec.Contains(str_cube_rdy)) //Si le cube est prêt à recevoir des données
                    {
                        if (cubeled != null)    //Si l'objet cubeled à été instancié,
                        {
                            rB_md_draw.Checked = false; //désactivation du radio bouton dessin                      
                            act_anim.Enabled = true;
                            act_draw.Enabled = true;
                            act_draw.Checked = false;   //Mise à jour des actions
                            act_anim.Checked = false;
                            tsmi_mode.Enabled = true;   //boutons du menu enabled
                            send_command(str_start_drawing);    //Envoi d'une commande d'envoi image
                            send_0x00();    //cube éteint!
                  
                         //   send_luminosité(cubeled.Luminosité);    //Envoi de la luminosité au cube
                        }
                        else
                        {
                            send_command(str_start_drawing);    //Envoi d'une commande d'envoi image
                            send_0x00();    //cube éteint!
                        }

                        btn_stop_usb.Enabled = true;    //Le cube est prêt à dialoguer via usb

                        MessageBox.Show("Le cube est prêt à recevoir des données!");
                    }

                    if (str_rec.Contains(str_cube_notrdy)) //Si le cube n'est pas prêt à recevoir des données
                    {
                        todo_in_stop_cube();    //Actions à réaliser une fois le mode du cube désactivé
                        MessageBox.Show("Le mode usb du cube est désactivé!");
                    }
                 
                   // }
                }

                //Code de traitement des données reçues (facultatif)

            }
        }

        /***************************************************************************
         * Fonction événementielle de fin d'envoi des données exécutée dans un thread.
         * Est déclenchée chaque fois que les données ont été envoyées
         * *************************************************************************/
        private void usbPort_OnDataSend(object sender, EventArgs args)
        {
            //Code de traitement des données suite à l'envoi des données
           // usb_data_sended = true; //Le flag passe à true!
        }

        #endregion


        #region perso

        private void todo_in_new_or_load()  //Liste des éléments modifiés lors d'une création de nouveau cube ou chargement A charger impérativement
        {
            lbl_T_image.Text = cubeled.T_image.ToString();
            timer_images.Interval = cubeled.T_image;    //Mise à jour de la valeur du timer

            combBox_image.Items.Clear();
            combBox_image.Height = cubeled.NB_images;   //mise à jour de la hauteur de la comboboxe nb_images

            for(int i=0;i<cubeled.NB_images;i++)    //écriture du nombre d'images à afficher
            {
                combBox_image.Items.Add("Image " + (i+1).ToString());  //Mise à jour du nombre d'images dans la comboboxe correspondante
            }

            combBox_image.SelectedIndex = 0;     //La première image (premier index) est sélectionnée!

            act_reglages.Enabled = true;    //Activation de l'action réglages
            combBox_image.Enabled = true;
            combBox_layer.Enabled = true;   //Activation des comboboxes

            if (cubeled.Mode_lum == 2)      //Si le mode de luminosité est variable
            {
                txtBox_Lum.Enabled = true;  //Le textbox luminosité est autorisé
            }
            else        //Sinon, si le mode de luminosité est fixe,
            {
                txtBox_Lum.Enabled = false; //Le textbox de luminosité est disabled
            }


            if ((cubeled != null)&& btn_stop_usb.Enabled)    //Si l'objet cubeled à déjà été instancié et que le cube est prêt à communiquer,  
            {
                rB_md_draw.Checked = false; //décheck des radioboutons
                rB_md_anim.Checked = false;  
                act_anim.Enabled = true;
                act_draw.Enabled = true;
                act_draw.Checked = false;   //Mise à jour des actions
                act_anim.Checked = false;
                act_play.Enabled = false;   //bouton play disabled 
                tsmi_mode.Enabled = true;   //boutons du menu enabled
            }
           

            
            
            en_cb(true);    //autorise les CB de dessin
            

            act_save.Enabled = true;                            //Autorisation de l'action de sauvegarde d'anim

            if (cubeled.Mode_lum == 2)  //Si luminosité en mode variable,
            {
                txtBox_Lum.Text = cubeled.img_lum[combBox_image.SelectedIndex].ToString();    //Chargement de la bonne luminosité en txtbox
            }
            else
            {
                txtBox_Lum.Text = cubeled.Luminosité.ToString();    //Mise à jour de l'edit de la luminosité (volontairement en dernier)
            }
        }




        private void todo_in_stop_cube()    //A réaliser lorsque le cube à confirmé son état d'arrêt de communication!
        {

            if (act_anim.Checked)   //Si mode animation en cours
            {
                en_cb(true);    //autorisation de l'interface cb
                rafraich_cb();  //Rafraichissement de cb
                act_play.Enabled = false;   //désactivation du mode play
                act_stop.Enabled = false;   //désactivation du mode stop
                act_pause.Enabled = false;  //désactivation du mode pause
                timer_images.Stop();        //Arrêt du timer
                if (cubeled.Mode_lum == 2)  //Si mode de luminosité variable,
                    txtBox_Lum.Enabled = true;  //Activation du textbox Lum
            }

            rB_md_draw.Checked = false; //désactivation des radio boutons 
            rB_md_anim.Checked = false;
            btn_stop_usb.Enabled = false;

            act_draw.Checked = false;   //Les états d'actions draw/anim sont mises à jour
            act_anim.Checked = false;
            act_draw.Enabled = false;
            act_anim.Enabled = false;

            if (cubeled != null)                //Si le cube existe déjà en mémoire
                act_reglages.Enabled = true;    //L'option réglages est réactivée
            else
                act_reglages.Enabled = false;   //Sinon, elle est désactivée

            tsmi_mode.Enabled = false;          //boutons du menu disabled
        }


        private void btn_stop_usb_Click(object sender, EventArgs e)
        {

            try
            {
                send_command(str_stop_usb); //Envoi de commande de déconnection au cube
            }
            catch (Exception err)
            {
                MessageBox.Show(err.Message, "Déconnection",
                                MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
        }


        //Envoie l'image n° via usb (selon le n° en mémoire et non pas le n° affiché à l'utilisateur!) 
        private void send_image_n(int image_no)     
        {
            try
            {
                usbPort.SpecifiedDevice.SendData(cubeled.send_image(image_no));
            }
            catch
            {

            }
        }


        //Fonction d'envoi des données sous forme d'une commande
        private void send_command(string strcmd)
        {
            try
            {
                int i = 1;

                foreach (byte dat in strcmd) //envoi message du mode usb!
                {
                    bufOut[i] = dat;    //enregistrement du caractère dans le buffer
                    i++;
                }
                do
                {
                    bufOut[i] = 0x00;
                    i++;
                }
                while (i < 65);    //remplit le restant du buffer de 0

                //Envoi de la trame de données mémorisée dans BufOut
                usbPort.SpecifiedDevice.SendData(bufOut.ToBytes());
            }
            catch
            {

            }
        }


        private void send_luminosité(int luminosité)        //envoie la commande, puis modifie la luminosité du cube!
        {
            try
            {
                send_command(str_mod_pwm);  //envoi de la commande de modifi pwm

                string strlum = luminosité.ToString("000");     //type de formatage du string (pour envoi en ascii)!

                int i = 1;

                foreach (byte dat in strlum) //préparation de la donnée à envoyer
                {
                    bufOut[i] = dat;    //enregistrement du caractère dans le buffer
                    i++;
                }
                do
                {
                    bufOut[i] = 0x00;
                    i++;
                }
                while (i < 65);    //remplit le restant du buffer de 0
                usbPort.SpecifiedDevice.SendData(bufOut.ToBytes()); //transmet la valeur du PWM en ascii
            }
            catch
            {

            }
        }



        private void en_cb(bool en_state)    //Permet d'enable or disable l'interface de leds!
        {
            for (int i = 0; i < nb_CBox_ligne * nb_ligne; i++)
            {
                cb_matrice[i].Enabled = en_state;   //changement de l'état
            }
        }



        private void rafraich_cb()    //Met à jour l'interface graphique de sélection leds
        {
            for (int i = 0; i < 64; i++)
                cb_matrice[i].MouseDown -= new MouseEventHandler(CBox_changed); //Désactivation de l'évenement des cb dessin leds

            for (int i = 0; i < 64; i++)   //répéter 64 fois
            {
                byte x = (byte)cubeled.datacube[(i / 8), étage_sel, image_sel];    //transfert des données du cube dans le buffer 

                byte y = (byte)(x & (0x80 >> (i % 8)));

                if (y != 0) //Si la valeur est vraie          
                    cb_matrice[i].BackColor = clled_on;
                else
                    cb_matrice[i].BackColor = clled_off;
            }

            for (int i = 0; i < 64; i++)
                cb_matrice[i].MouseDown += new MouseEventHandler(CBox_changed); //Réactivation de l'événement des cb dessin leds
        }


        private void send_0x00()    //permet l'envoi d'une trame de 0 (à placer entre deux même trames consecutives)
        {
            try
            {
                for (int i = 0; i < 65; i++)
                {
                    bufOut[i] = 0x00;
                }

                //Envoi de la trame de données mémorisée dans BufOut
                usbPort.SpecifiedDevice.SendData(bufOut.ToBytes());
            }
            catch
            {

            }
        }

        #endregion


        #region Application

       


        public void combBox_image_layer_changed(object sender, EventArgs e)     //Si l'un des deux éléments combobox est modifié,
        {                                                                       //Mise à jour de la variable à afficher
                                                        
            image_sel = combBox_image.SelectedIndex;    //enregistrement du n° de l'image     
            étage_sel = Array.IndexOf(str_étages, combBox_layer.Text);   //enregistrement du n° de l'étage

            if (cubeled.Mode_lum == 2)  //Si le mode de luminosité est variable,
            {
                txtBox_Lum.TextChanged -= new EventHandler(txtBox_Lum_TextChanged);     //Désactivation de l'évenement on text modif,
                txtBox_Lum.Text = cubeled.img_lum[image_sel].ToString();    //modification du champ de la textbox en fonction de la luminosité
                txtBox_Lum.TextChanged += new EventHandler(txtBox_Lum_TextChanged);     //Autorisation de l'évenement on text modif,
            }

            if (btn_stop_usb.Enabled && ((act_draw.Checked) || (act_anim.Checked)))   //Si le cube prêt à recevoir des données, et que l'envoi est autorisé,
            {

                if (cubeled.Mode_lum == 2)  //Si le mode de luminosité est variable,
                {
                    send_luminosité(cubeled.img_lum[image_sel]);    //Envoi de la bonne luminosité
                }
                send_command(str_start_drawing);    //Envoi d'une commande dessin
                //envoi de l'image sélectionnée au cube via usb
                send_image_n(image_sel);            
            }

            if (act_anim.Checked == false)  //Si animation n'est pas en cours,
                //rafraichissement de l'état des checkboxes
                rafraich_cb();
            
        }

        private void toolStripContainer1_ContentPanel_Load(object sender, EventArgs e)
        {
                //Constantes hauteur largeur, séparations etc.
                const int margeGauche = 350, margeSupérieure = 120, largeur = 25, hauteur = 25, sepH = 2, sepV = 2;


                int posH = 0, posV = 0;

                //Instanciation du clavier (tableau de boutons) 
                cb_matrice = new Label[nb_CBox_ligne * nb_ligne];

                tsc_main.SuspendLayout();    //Suspend le layout du toolstripcontainer principal

                //Création des CheckBoxes 
                for (int i = 0; i < nb_CBox_ligne * nb_ligne; i++)
                {
                    //Calcul la position du bouton 
                    posH = margeGauche + (largeur + sepH) * (i % nb_CBox_ligne);
                    posV = margeSupérieure + (hauteur + sepV) * (i / nb_CBox_ligne);

                    //Instancie le bouton  
                    cb_matrice[i] = new Label();
                    cb_matrice[i].Parent = this;
                    cb_matrice[i].BackColor = Color.White;

                    //Défini les caractéristiques du bouton 
                    cb_matrice[i].Location = new System.Drawing.Point(posH, posV);
                    cb_matrice[i].Size = new System.Drawing.Size(largeur, hauteur);
                    cb_matrice[i].Text = "";// (txt_btn[i]).ToString();    //Affichage du txt des touches correspondantes
                    cb_matrice[i].Name = i.ToString();
                    cb_matrice[i].Enabled = false;  //Disabled au démarrage

                    cb_matrice[i].BringToFront();   //Fait passer la CB au premier plan

                    //Associe la procédure événementielle 
                    cb_matrice[i].MouseDown += new MouseEventHandler(CBox_changed); //Quand la souris se trouve sur la zone et qu'un de ses bouton est enfoncé,
                }
                tsc_main.ResumeLayout();    //Résume le layout du toolstrip


                image_sel = combBox_image.SelectedIndex;    //enregistrement du n° de l'image   
                étage_sel = Array.IndexOf(str_étages, combBox_layer.Text);   //enregistrement du n° de l'étage
        }

        private void act_about_Execute(object sender, EventArgs e)
        {
            frm_à_propos.ShowDialog();  //Affiche la boîte de dialogue à propos de
        }

        private void act_quit_Execute(object sender, EventArgs e)
        {
            Close();    //quitte le programme
        }

        private void frmMain_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (btn_stop_usb.Enabled)   //Si le cube est connecté et prêt à communiquer,
            {
                try
                {
                    send_command(str_stop_usb);    //Indication d'arrêt de communication au cube!
                    send_0x00();    //Suivi de 0 si besoin de renvoyer la même commande de suite au uC (sécurité)
                }
                catch
                {

                }
            }
        }

        private void act_draw_Execute(object sender, EventArgs e)
        {
            act_reglages.Enabled = true;    //L'option réglages est réactivée
            act_draw.Checked= true;     //Pour les menus aussi, check
            act_anim.Checked = false;   //Pour les menus aussi, decheck

            act_pause.Enabled = false;
            act_play.Enabled = false;
            act_stop.Enabled = false;   //Désactivation des actions d'animations
            rB_md_draw.Checked = act_draw.Checked;  //activation du radiobouton


            timer_images.Stop();    //Le timer est arrêté

            for (int i = 0; i < nb_CBox_ligne * nb_ligne; i++)
            {

                cb_matrice[i].Enabled = true;  //Les CBoxes sont autorisées
            }

            //L'état des Cbox sera mis à jour
            rafraich_cb();


            if (cubeled.Mode_lum == 2)  //Si mode de luminosité variable,
            {
                txtBox_Lum.Enabled = true; //Activation du textbox Lum
                send_luminosité(cubeled.img_lum[image_sel]);  //Envoi de la luminosité de limage
            }
            else
            {
                send_luminosité(cubeled.Luminosité);    //Envoi de la luminosité spécifiée pour l'anim
            }
            send_command(str_start_drawing);    //Commande de mode envoi image

            //Envoi de l'image à afficher au cube via usb
            send_image_n(image_sel);
        }

        private void act_anim_Execute(object sender, EventArgs e)
        {
          
            act_play.Enabled = true;    //Activation de l'action d'animation       
            act_draw.Checked = false;   //Pour les menus aussi, decheck
            act_anim.Checked = true;    //Pour les menus aussi, check
            rB_md_anim.Checked = act_anim.Checked;  //le radio bouton prends l'etat
            txtBox_Lum.Enabled = false; //Désactivation du textbox Lum
            act_reglages.Enabled = false;   //Désactive la posibilité de réglages

            if (cubeled.Mode_lum == 2)  //Si mode de luminosité variable,
            {              
                send_luminosité(cubeled.img_lum[image_sel]);  //Envoi de la luminosité de limage
            }
            else
            {
                send_luminosité(cubeled.Luminosité);    //Envoi de la luminosité spécifiée pour l'anim
            }


            if(combBox_image.SelectedIndex == 0)    //Si l'index est déjà à 0,
            {
                send_command(str_start_drawing);    //Envoi d'une commande dessin
                //envoi de la première image au cube!
                send_image_n(0);
            }
            else
            {
                combBox_image.SelectedIndex = 0;    //Sélection de l'image 0 (qui sera automatiquement chargée via l'évenement onChange du combox)
            }
            
            
            en_cb(false);  //Disable l'interface cb (leds) au démarrage du mode anim

            for (int i = 0; i < nb_CBox_ligne * nb_ligne; i++)
            {
                cb_matrice[i].BackColor = Control.DefaultBackColor; //Color.control //Changement de la couleur des cb pour les rendre invisibles
            }

        }



        

        private void act_reglages_Execute(object sender, EventArgs e)
        {
            //Instanciation d'une boite de dialogue perso avec valeurs courantes
            FrmSettings settingbox = new FrmSettings(cubeled.NB_images, cubeled.T_image, cubeled.Luminosité, cubeled.Mode_lum, "Réglages");    

            //Affiche la boite de dialogue et si la réponse est ok
            if (settingbox.ShowDialog() == DialogResult.OK)
            {
                Classcube oldcubeled = cubeled;         //Création d'un cube et copie des données actuelles dans celui-ci
                int buff_nb_image_cpy = 0;      //Stock la valeur max pour les boucles de copie d'images et lum

                //Enregistrement des nouveaux paramètres dans cubeled (réinstanciation)
                cubeled = new Classcube(settingbox.Nb_images, settingbox.T_images, settingbox.Luminosité, settingbox.Mode_lum);

                if (cubeled.NB_images > oldcubeled.NB_images)   //Si l'utilisateur à augmenté le nombre d'images,
                {
                    buff_nb_image_cpy = oldcubeled.NB_images;   //Le plus petit nombre est sélectionné
                }
                else                                            //Sinon, le nouveau nombre est conservé
                {
                    buff_nb_image_cpy = cubeled.NB_images;   
                }

                //Copie des images du buffer dans le cube ledcube en mémoire
                for (int k = 0; k < buff_nb_image_cpy; k++)     //Pour le nombre d'images à charger en ram (0 à x)
                        for (int i = 0; i < 8; i++)                 //Rempli la par (par étages) (du 0 au 7)
                            for (int j = 0; j < 8; j++)             //Par lignes (0 à 7)
                            {
                                cubeled.datacube[j, i, k] = oldcubeled.datacube[j,i,k];     //Transfert des données de l'ancien cube vers le nouveau
                            }

                //Copie du tableau de luminosité

                for (int i = 0; i < buff_nb_image_cpy; i++)     //Pour le nombre d'images nécessaires,
                {
                    cubeled.img_lum[i] = oldcubeled.img_lum[i];    //lecture et enregistrement des valeurs dans l'objet ledcube.
                }


                 bool old_mode_draw_chk = act_draw.Checked; //Sauvegarde de l'ancien état du mode draw

                todo_in_new_or_load();  //Mise à jour des édits
        
                if (old_mode_draw_chk)  //Si le mode draw était actif,
                    act_draw_Execute(sender, e);    //éxecution du l'action
            }
        }

        private void act_nouveau_Execute(object sender, EventArgs e)
        {
            if ((act_play.Enabled) || (act_pause.Enabled))   //Si mode play ou pause en cours,
                act_stop_Execute(sender, e);     //Stop de l'animation en cours


            FrmSettings newbox = new FrmSettings(Classcube.get_nb_image_default(), Classcube.get_t_image_default(), Classcube.get_lum_default(), Classcube.get_mode_lum_default(), frm_name_new);    //instanciation d'une boite de dialogue newcube avec valeur default de la Classecube

            //Affiche la boite de dialogue et si la réponse est ok
            if (newbox.ShowDialog() == DialogResult.OK)
            {
                cubeled = new Classcube(newbox.Nb_images, newbox.T_images, newbox.Luminosité, newbox.Mode_lum);  //Instanciation du nouveau cube en mémoire!
                todo_in_new_or_load();  ///Mise à jour de tout ce qu'il faut (flags, autorisations etc..)
            }
        }

        private void timer_images_Tick(object sender, EventArgs e)
        {
            if (btn_stop_usb.Enabled)   //Si le cube est prêt à recevoir des données
            {
            
                int newindex =  (combBox_image.SelectedIndex+1) % cubeled.NB_images;    //Calcul du nouvel index
                combBox_image.SelectedIndex = newindex; //Changement de l'index et post-incrémentation         
            }
        }

        private void act_play_Execute(object sender, EventArgs e)
        {
            timer_images.Start();       //Le timer est activé
            act_play.Enabled = false;   //désactivation du mode play
            act_stop.Enabled = true;    //Activation du mode stop
            act_pause.Enabled = true;   //Activation du mode pause
        }

        private void act_pause_Execute(object sender, EventArgs e)
        {
            timer_images.Stop();       //Le timer est désactivé
            act_play.Enabled = true;   //Activation du mode play
        }

        private void act_stop_Execute(object sender, EventArgs e)
        {
            timer_images.Stop();       //Le timer est désactivé
            combBox_image.SelectedIndex = 0;//l'index 0 (image 1) est sélectionné 
            act_stop.Enabled = false;       //désactivation du mode stop
            act_pause.Enabled = false;      //désactivation du mode pause
            act_play.Enabled = true;        //activation du mode play

        }

        private void txtBox_Lum_TextChanged(object sender, EventArgs e)
        {

            if ((cubeled.Mode_lum == 2) && (!act_anim.Checked)) //Si le mode luminosité variable est actif, et que le mode d'animation n'est pas en cours
            {
                try
                {
                    cubeled.img_lum[combBox_image.SelectedIndex] = int.Parse(txtBox_Lum.Text);  //Enregistrement de la valeur lum en mémoire
                }
                catch
                {

                }
                if (btn_stop_usb.Enabled)   //Si le cube est prêt à communiquer
                {
                    send_luminosité(cubeled.img_lum[combBox_image.SelectedIndex]);  //Envoi de la nouvelle luminosité au cube
                }
            }
        }

        private void txtBox_Lum_KeyDown(object sender, KeyEventArgs e)  //Filtrage des touches
        {
            if (!(((e.KeyCode >= Keys.D0) && (e.KeyCode <= Keys.D9)) || ((e.KeyCode >= Keys.NumPad0) && (e.KeyCode <= Keys.NumPad9)) || (Keys.Right.Equals(e.KeyCode)) || (Keys.Left.Equals(e.KeyCode)) || (Keys.Back.Equals(e.KeyCode)) || (Keys.Delete.Equals(e.KeyCode))))      //Si touche invalide
            {
                e.SuppressKeyPress = true;  //touche sans effet
            }
        }

        private void txtBox_Lum_Validated(object sender, EventArgs e)
        {
            if (txtBox_Lum.Text == "")  //Si le textbox est vide
            {
                txtBox_Lum.Text = 0.ToString();    //Ecriture de 0 dans textbox     
            }
            else if (int.Parse(txtBox_Lum.Text) > 100)  //Sinon, si la valeur est trop élevée,
            {
                txtBox_Lum.Text = 100.ToString();   //remise à la valeur max
            }
        }

        private void act_open_Execute(object sender, EventArgs e)
        {
            FileStream file_strm;    //Conteneur pour le filestream
            BinaryReader brdfile;

            if ((act_play.Enabled)||(act_pause.Enabled))   //Si mode play ou pause en cours,
                act_stop_Execute(sender,e);     //Stop de l'animation en cours

            try
            {
                //Ouverture de la boite de dialogue d'ouverture fichier!
                if (openfilediabox.ShowDialog() == DialogResult.OK) //Si un fichier est ouvert
                {
                    try
                    {
                        int pos = 11;
                        string buff_nb_images = "";
                        string buff_lum_mode = "";
                        string buff_tempo = "";

                        file_strm = new FileStream(openfilediabox.FileName, FileMode.Open, FileAccess.Read); //Création du stream  
                        brdfile = new BinaryReader(file_strm);      //Instanciation d'un Binary Reader

                        file_strm.Seek(pos, SeekOrigin.Begin);      //Déplacement au paremier caractère utile début du fichier (nB_images)

                        //Acquisition du nombre d'images,
                        do
                        {
                            buff_nb_images += brdfile.ReadChar();   //Acquisition du caractère
                            pos++;  //mets à jour la position actuelle dans le flux
                        } while (brdfile.PeekChar() != ',');   //tant qu'une virgule n'est pas rencontrée

                        pos++;  //pour quitter la virgule et se déplacer sur le nouveau champ!
                        file_strm.Seek(pos, SeekOrigin.Begin);    //Déplacement dans le stream

                        //Acquisition du type de gestion lumière
                        do
                        {
                            buff_lum_mode += brdfile.ReadChar();   //Acquisition du caractère
                            pos++;  //mets à jour la position actuelle dans le flux
                        } while (brdfile.PeekChar() != ',');   //tant qu'une virgule n'est pas rencontrée

                        pos++;  //pour quitter la virgule et se déplacer sur le nouveau champ!
                        file_strm.Seek(pos, SeekOrigin.Begin);    //Déplacement dans le stream


                        //Acquisition de la valeur de temporisation
                        do
                        {
                            buff_tempo += brdfile.ReadChar();   //Acquisition du caractère
                            pos++;  //mets à jour la position actuelle dans le flux
                        } while (brdfile.PeekChar() != '$');    //tant que le caractère de fin d'entête n'est pas rencontré

                        pos += 2;   //déplacement sur le premier byte de l'image 0 étage 0 ligne 0!

                        file_strm.Seek(pos, SeekOrigin.Begin);  //Déplacement dans le stream

                        try
                        {
                            cubeled = new Classcube(int.Parse(buff_nb_images), int.Parse(buff_tempo), Classcube.get_lum_default(), int.Parse(buff_lum_mode));    //Instanciation du cube avec valeur de luminosité par défaut

                            for (int k = 0; k < cubeled.NB_images; k++)     //Pour le nombre d'images à charger en ram (0 à x)
                                for (int i = 0; i < 8; i++)                 //Rempli la par (par étages) (du 0 au 7)
                                    for (int j = 0; j < 8; j++)             //Par lignes (0 à 7)
                                    {
                                        cubeled.datacube[j, i, k] = brdfile.ReadByte(); //Transfert des données du fichier dans le cube en mémoire
                                        pos++;  //incrémentation de la position dans le fichier
                                    }

                            pos += 2;//déplacement au début du caractère utile du champ contenant la luminosité (en byte(s))!

                            file_strm.Seek(pos, SeekOrigin.Begin);    //Déplacement dans le stream


                            if (cubeled.Mode_lum == 2)  //Si le mode de gestion luminosité est variable,
                            {
                                for (int i = 0; i < cubeled.NB_images; i++)      //Pour le nombre d'images nécessaires,
                                {
                                    cubeled.img_lum[i] = brdfile.ReadByte();    //lecture et enregistrement des valeurs dans l'objet ledcube.
                                }
                            }
                            else    //Sinon, si le mode est fixe
                            {
                                cubeled.Luminosité = brdfile.ReadByte(); //Acquisition de la luminosité
                            }

                            file_strm.Close();      //Fermeture du fichier
                            todo_in_new_or_load();  //Mise à jour de tout ce qu'il faut (flags, autorisations etc..)

                            rafraich_cb();                       //MAJ des Cboxes

                        }
                        catch (Exception err)
                        {
                            MessageBox.Show("Erreur : " + err.ToString());  //Affiche l'exception
                        }


                    }
                    catch (Exception err)
                    {
                        MessageBox.Show("Erreur à l'ouverture du fichier: " + err.ToString());  //Affichage de l'exception
                    }
                }
 
            }
            catch (Exception err)
            {
                MessageBox.Show("Erreur : " + err.ToString());  //Affiche l'exception
            }
        }

        private void act_save_Execute(object sender, EventArgs e)
        {
            FileStream filenew_strm;    //Conteneurs pour filestream et BinaryWriter
            BinaryWriter bwrnewfile;

            if ((act_play.Enabled) || (act_pause.Enabled))  //Si mode play ou pause en cours,
                act_stop_Execute(sender, e);    //Stop de l'animation en cours

            try
            {
                //ouverture de la boite de dialogue pour l'enregistrement du nouveau fichier
                if (savefilediabox.ShowDialog() == DialogResult.OK)   //Si appui enregistrer
                {
                    try
                    {
                        filenew_strm = new FileStream(savefilediabox.FileName, FileMode.Create, FileAccess.ReadWrite);  //création du stream
                        bwrnewfile = new BinaryWriter(filenew_strm);    //Instanciation d'un Binary Writer

                        filenew_strm.Seek(0, SeekOrigin.Begin);     //Déplacement au début du fichier

                        foreach (byte dat in str_entête_file)
                            bwrnewfile.Write(dat);          //écriture de l'entête du fichier


                        foreach (byte dat in cubeled.NB_images.ToString())
                            bwrnewfile.Write(dat);          //écriture du nombre d'images

                        bwrnewfile.Write(',');

                        foreach (byte dat in cubeled.Mode_lum.ToString())
                            bwrnewfile.Write(dat);          //écriture du mode de luminosité

                        bwrnewfile.Write(',');              //Séparateur

                        foreach (byte dat in cubeled.T_image.ToString())
                            bwrnewfile.Write(dat);          //écriture de la temporisation

                        bwrnewfile.Write('$');              //Séparateur fin et nouvel entête
                        bwrnewfile.Write('#');


                        for (int k = 0; k < cubeled.NB_images; k++)     //Pour le nombre d'images contenues en ram (0 à x)
                            for (int i = 0; i < 8; i++)                 //envoie l'image 3D au cube (par étages) (du 0 au 7)
                                for (int j = 0; j < 8; j++)             //lignes (0 à 7)
                                {
                                    bwrnewfile.Write(cubeled.datacube[j, i, k]);   //transfert des données du cube dans le buffer
                                }

                        bwrnewfile.Write('$');      //Séparateur fin et nouvel entête
                        bwrnewfile.Write('#');

                        if (cubeled.Mode_lum == 2)  //Si le mode gestion de l'intensité lumineuse est variable,
                        {
                            for (int i = 0; i < cubeled.NB_images; i++)     //Pour le nombre d'images existantes 
                                bwrnewfile.Write((byte)cubeled.img_lum[i]); //Ecriture des intensités unes à unes dans le stream (de la 0 à x)
                        }
                        else
                        {
                            bwrnewfile.Write((byte)cubeled.Luminosité);     //Envoi de la luminosité fixe!
                        }

                        bwrnewfile.Write('$');   //Fin du champ actuel!

                        bwrnewfile.Flush();                                 //Ecriture dans le fichier!
                        filenew_strm.Close();                               //Fermeture du fichier!

                    }
                    catch (Exception err)
                    {
                        MessageBox.Show("Erreur de création fichier: " + err.ToString());   //Affichage de l'exception
                    }
                }
            }
            catch (Exception err)
            {
                MessageBox.Show("Erreur: " + err.ToString());   //Affichage de l'exception
            }
        }

    }
}


        #endregion
