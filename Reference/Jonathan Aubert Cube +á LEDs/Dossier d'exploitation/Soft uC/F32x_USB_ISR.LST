C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE F32X_USB_ISR
OBJECT MODULE PLACED IN F32x_USB_ISR.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE F32x_USB_ISR.c OPTIMIZE(3,SPEED) BROWSE INCDIR(.\Header;.\Lib) DEBUG OBJECT
                    -EXTEND TABS(3)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F32x_USB_ISR.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2005 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          // FID:            32X000022
   7          // Target:         C8051F32x
   8          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
   9          // Release 1.3
  10          // Adaptation pour modèle usbhid du cfpt : Neuhaus Jacques ( 30 juin 2010)
  11          //----------------------------------------------------------------------------
  12          
  13          #include "c8051F320.h"
  14          #include "GlobalDef.h"
  15          #include "GlobalDef_usbhid.h"
  16          #include "F32x_USB_Register.h"
  17          #include "F32x_USB_Descriptor.h"
  18          #include "F32x_USB_Endpoint.h"
  19          
  20          //-----------------------------------------------------------------------------
  21          // Global Variables
  22          //-----------------------------------------------------------------------------
  23          
  24          //--- Buffer de données couche usb
  25          xdata BYTE Out_Packet[EP2_PACKET_SIZE]; // Last packet received from host
  26          xdata BYTE In_Packet[EP1_PACKET_SIZE];  // Next packet to sent to host
  27          
  28          //--- Flag indiquant que de nouvelles données ont été reçues
  29          bit fNewData=0;  
  30          
  31          //-----------------------------------------------------------------------------
  32          BYTE USB_State;                        // Holds the current USB State
  33                                                 // def. in F32x_USB_Main.h
  34          setup_buffer Setup;                    // Buffer for current device request
  35          
  36          unsigned int DataSize;                 // Size of data to return
  37          unsigned int DataSent;                 // Amount of data sent so far
  38          BYTE* DataPtr;                         // Pointer to data to return
  39          
  40          // Holds the status for each endpoint
  41          BYTE Ep_Status[3] = {EP_IDLE, EP_IDLE, EP_IDLE};
  42          
  43          //-----------------------------------------------------------------------------
  44          // Local function prototype
  45          //-----------------------------------------------------------------------------
  46          
  47          void Get_Report(void);
  48          
  49          //-----------------------------------------------------------------------------
  50          // Interrupt Service Routines
  51          //-----------------------------------------------------------------------------
  52          
  53          //-----------------------------------------------------------------------------
  54          // Usb_ISR
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 2   

  55          //-----------------------------------------------------------------------------
  56          //
  57          // Called after any USB type interrupt, this handler determines which type
  58          // of interrupt occurred, and calls the specific routine to handle it.
  59          //
  60          //-----------------------------------------------------------------------------
  61          void Usb_ISR(void) interrupt INTERRUPT_USB0
  62          {
  63   1         BYTE bCommon, bIn, bOut;
  64   1         POLL_READ_BYTE(CMINT, bCommon);     // Read all interrupt registers
  65   1         POLL_READ_BYTE(IN1INT, bIn);        // this read also clears the register
  66   1         POLL_READ_BYTE(OUT1INT, bOut);
  67   1         {
  68   2            if (bCommon & rbRSUINT)          // Handle Resume interrupt
  69   2            {
  70   3               Usb_Resume();
  71   3            }
  72   2            if (bCommon & rbRSTINT)          // Handle Reset interrupt
  73   2            {
  74   3               Usb_Reset();
  75   3            }
  76   2            if (bIn & rbEP0)                 // Handle Setup packet received
  77   2            {                                // or packet transmitted if Endpoint 0
  78   3               Handle_Setup();               // is transmit mode
  79   3            }
  80   2            if (bIn & rbIN1)                 // Handle In Packet sent, put new data
  81   2            {                                // on endpoint 1 fifo
  82   3               Handle_In1();
  83   3            }
  84   2            if (bOut & rbOUT2)               // Handle Out packet received, take data
  85   2            {                                // off endpoint 2 fifo
  86   3               Handle_Out2();
  87   3            }
  88   2            if (bCommon & rbSUSINT)          // Handle Suspend interrupt
  89   2            {
  90   3               Usb_Suspend();
  91   3            }
  92   2         }
  93   1      }
  94          
  95          //-----------------------------------------------------------------------------
  96          // Support Routines for ISR
  97          //-----------------------------------------------------------------------------
  98          
  99          //-----------------------------------------------------------------------------
 100          // Usb_Reset
 101          //-----------------------------------------------------------------------------
 102          //
 103          // Return Value : None
 104          // Parameters   : None
 105          //
 106          // - Set state to default
 107          // - Clear Usb Inhibit bit
 108          //
 109          //-----------------------------------------------------------------------------
 110          
 111          void Usb_Reset(void)
 112          {
 113   1         USB_State = DEV_DEFAULT;            // Set device state to default
 114   1      
 115   1         POLL_WRITE_BYTE(POWER, 0x01);       // Clear usb inhibit bit to enable USB
 116   1                                             // suspend detection
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 3   

 117   1      
 118   1         Ep_Status[0] = EP_IDLE;             // Set default Endpoint Status
 119   1         Ep_Status[1] = EP_HALT;
 120   1         Ep_Status[2] = EP_HALT;
 121   1      }
 122          
 123          //-----------------------------------------------------------------------------
 124          // Handle_Setup
 125          //-----------------------------------------------------------------------------
 126          //
 127          // Return Value : None
 128          // Parameters   : None
 129          //
 130          // - Decode Incoming Setup requests
 131          // - Load data packets on fifo while in transmit mode
 132          //
 133          //-----------------------------------------------------------------------------
 134          
 135          void Handle_Setup(void)
 136          {
 137   1         BYTE ControlReg,TempReg;            // Temporary storage for EP control
 138   1                                             // register
 139   1      
 140   1         POLL_WRITE_BYTE(INDEX, 0);          // Set Index to Endpoint Zero
 141   1         POLL_READ_BYTE(E0CSR, ControlReg);  // Read control register
 142   1      
 143   1         if (Ep_Status[0] == EP_ADDRESS)     // Handle Status Phase of Set Address
 144   1                                             // command
 145   1         {
 146   2            POLL_WRITE_BYTE(FADDR, Setup.wValue.c[LSB]);
 147   2            Ep_Status[0] = EP_IDLE;
 148   2         }
 149   1      
 150   1         if (ControlReg & rbSTSTL)           // If last packet was a sent stall, reset
 151   1         {                                   // STSTL bit and return EP0 to idle state
 152   2            POLL_WRITE_BYTE(E0CSR, 0);
 153   2            Ep_Status[0] = EP_IDLE;
 154   2            return;
 155   2         }
 156   1      
 157   1         if (ControlReg & rbSUEND)           // If last setup transaction was ended
 158   1         {                                   // prematurely then set
 159   2            POLL_WRITE_BYTE(E0CSR, rbDATAEND);
 160   2            POLL_WRITE_BYTE(E0CSR, rbSSUEND); // Serviced Setup End bit and return EP0
 161   2            Ep_Status[0] = EP_IDLE;          // to idle state
 162   2         }
 163   1      
 164   1         if (Ep_Status[0] == EP_IDLE)        // If Endpoint 0 is in idle mode
 165   1         {
 166   2            if (ControlReg & rbOPRDY)        // Make sure that EP 0 has an Out Packet ready from host
 167   2            {                                // although if EP0 is idle, this should always be the case
 168   3               Fifo_Read(FIFO_EP0, 8, (BYTE *)&Setup);
 169   3                                              // Get Setup Packet off of Fifo, it is currently Big-Endian
 170   3      
 171   3                                             // Compiler Specific - these next three statements swap the
 172   3                                             // bytes of the setup packet words to Big Endian so they
 173   3                                             // can be compared to other 16-bit values elsewhere properly
 174   3               Setup.wValue.i = Setup.wValue.c[MSB] + 256*Setup.wValue.c[LSB];
 175   3               Setup.wIndex.i = Setup.wIndex.c[MSB] + 256*Setup.wIndex.c[LSB];
 176   3               Setup.wLength.i = Setup.wLength.c[MSB] + 256*Setup.wLength.c[LSB];
 177   3      
 178   3                                             // <-- class specific request support
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 4   

 179   3            // Intercept HID class-specific requests
 180   3            if(   ((Setup.bmRequestType&~0x80)==DSC_CLASS)
 181   3               && ( Setup.wIndex.i == 0 )                ) {
 182   4               switch(Setup.bRequest) {
 183   5                  case GET_REPORT: 
 184   5                     Get_Report();
 185   5                     break;
 186   5      /****
 187   5                  case SET_REPORT: 
 188   5                     Set_Report();
 189   5                     break;
 190   5                  case GET_IDLE: 
 191   5                     Get_Idle();
 192   5                     break;
 193   5                  case SET_IDLE: 
 194   5                     Set_Idle();
 195   5                     break;
 196   5                  case GET_PROTOCOL: 
 197   5                     Get_Protocol();
 198   5                     break;
 199   5                  case SET_PROTOCOL: 
 200   5                     Set_Protocol();
 201   5                     break;
 202   5      ****/
 203   5                     default:
 204   5                        Force_Stall();           // Send stall to host if invalid request
 205   5                        break;
 206   5               }
 207   4            } else {
 208   4      
 209   4                  switch(Setup.bRequest)        // Call correct subroutine to handle each kind of
 210   4                  {                             // standard request
 211   5                      case GET_STATUS:
 212   5                         Get_Status();
 213   5                         break;
 214   5                      case CLEAR_FEATURE:
 215   5                         Clear_Feature();
 216   5                         break;
 217   5                      case SET_FEATURE:
 218   5                         Set_Feature();
 219   5                         break;
 220   5                      case SET_ADDRESS:
 221   5                         Set_Address();
 222   5                         break;
 223   5                      case GET_DESCRIPTOR:
 224   5                         Get_Descriptor();
 225   5                         break;
 226   5                      case GET_CONFIGURATION:
 227   5                         Get_Configuration();
 228   5                         break;
 229   5                      case SET_CONFIGURATION:
 230   5                         Set_Configuration();
 231   5                         break;
 232   5                      case GET_INTERFACE:
 233   5                         Get_Interface();
 234   5                         break;
 235   5                      case SET_INTERFACE:
 236   5                         Set_Interface();
 237   5                         break;
 238   5                      default:
 239   5                         Force_Stall();          // Send stall to host if invalid request
 240   5                         break;
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 5   

 241   5                   }
 242   4      
 243   4               }
 244   3            }
 245   2         }
 246   1      
 247   1         if (Ep_Status[0] == EP_TX)          // See if the endpoint has data to transmit to host
 248   1         {
 249   2            if (!(ControlReg & rbINPRDY))    // Make sure you don't overwrite last packet
 250   2            {
 251   3                                             // Endpoint 0 transmit mode
 252   3               
 253   3               POLL_READ_BYTE(E0CSR, ControlReg);
 254   3                                             // Read control register
 255   3      
 256   3               if ((!(ControlReg & rbSUEND)) || (!(ControlReg & rbOPRDY)))
 257   3                                             // Check to see if Setup End or Out Packet received, if so
 258   3                                             // do not put any new data on FIFO
 259   3               {
 260   4                  TempReg = rbINPRDY;        // Add In Packet ready flag to E0CSR bitmask
 261   4      
 262   4                                             // Break Data into multiple packets if larger than Max Packet
 263   4                  if (DataSize >= EP0_PACKET_SIZE)
 264   4                  {
 265   5                     Fifo_Write(FIFO_EP0, EP0_PACKET_SIZE, (BYTE *)DataPtr);// Put Data on Fifo
 266   5                     DataPtr  += EP0_PACKET_SIZE;                           // Advance data pointer
 267   5                     DataSize -= EP0_PACKET_SIZE;                           // Decrement data size
 268   5                     DataSent += EP0_PACKET_SIZE;                           // Increment data sent counter
 269   5                  }
 270   4                  else                       // If data is less than Max Packet size or zero
 271   4                  {
 272   5                     Fifo_Write(FIFO_EP0, DataSize, (BYTE *)DataPtr);       // Put Data on Fifo
 273   5                     TempReg |= rbDATAEND;                                  // Add Data End bit to bitmask
 274   5                     Ep_Status[0] = EP_IDLE;                                // Return EP 0 to idle state
 275   5                  }
 276   4                  if (DataSent == Setup.wLength.i)
 277   4                                              // This case exists when the host requests an even multiple of
 278   4                                              // your endpoint zero max packet size, and you need to exit
 279   4                                              // transmit mode without sending a zero length packet
 280   4                  {
 281   5                     TempReg |= rbDATAEND;    // Add Data End bit to mask
 282   5                     Ep_Status[0] = EP_IDLE;  // and return Endpoint 0 to an idle state
 283   5                  }
 284   4                  POLL_WRITE_BYTE(E0CSR, TempReg);                          // Write mask to E0CSR
 285   4               }
 286   3            }
 287   2         }
 288   1      }
 289          
 290          //-----------------------------------------------------------------------------
 291          // Handle_In1 (In vu du PC, données à envoyer pour le micro)
 292          //-----------------------------------------------------------------------------
 293          //
 294          // Return Value : None
 295          // Parameters   : None
 296          //
 297          // This routine loads the current value from In_Packet on the Endpoint 1 fifo,
 298          // after  an interrupt is received from the last packet being transmitted
 299          //
 300          //-----------------------------------------------------------------------------
 301          
 302          void Handle_In1()
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 6   

 303          {
 304   1         BYTE ControlReg;
 305   1      
 306   1         POLL_WRITE_BYTE(INDEX, 1);           // Set index to endpoint 1 registers
 307   1         POLL_READ_BYTE(EINCSR1, ControlReg); // Read contol register for EP 1
 308   1      
 309   1         if (Ep_Status[1] == EP_HALT)         // If endpoint is currently halted, 
 310   1                                              // send a stall
 311   1         {
 312   2            POLL_WRITE_BYTE(EINCSR1, rbInSDSTL);
 313   2         }
 314   1      
 315   1         else                                 // Otherwise send last updated 
 316   1                                              // data to host
 317   1         {
 318   2            if (ControlReg & rbInSTSTL)       // Clear sent stall if last packet
 319   2                                             // returned a stall
 320   2            {
 321   3               POLL_WRITE_BYTE(EINCSR1, rbInCLRDT);
 322   3            }
 323   2      
 324   2            if (ControlReg & rbInUNDRUN)      // Clear underrun bit if it was set
 325   2            {
 326   3               POLL_WRITE_BYTE(EINCSR1, 0x00);
 327   3            }
 328   2      
 329   2                                              // Put new data on Fifo
 330   2            //Fifo_Write(FIFO_EP1, EP1_PACKET_SIZE, (BYTE *)IN_PACKET);
 331   2            Fifo_Write(FIFO_EP1, EP1_PACKET_SIZE, In_Packet);
 332   2            POLL_WRITE_BYTE(EINCSR1, rbInINPRDY);
 333   2                                              // Set In Packet ready bit, indicating 
 334   2         }                                    // fresh data on Fifo 1
 335   1      }
 336          
 337          //-----------------------------------------------------------------------------
 338          // Handle_Out2 (Out vu du PC, données reçues pour le micro)
 339          //-----------------------------------------------------------------------------
 340          //
 341          // Return Value : None
 342          // Parameters   : None
 343          //
 344          // Take the received packet from the host off the fifo and put it into
 345          // the Out_Packet array
 346          //
 347          //-----------------------------------------------------------------------------
 348          
 349          void Handle_Out2()
 350          {
 351   1         BYTE Count = 0;
 352   1         BYTE ControlReg;
 353   1      
 354   1         POLL_WRITE_BYTE(INDEX, 2);          // Set index to endpoint 2 registers
 355   1         POLL_READ_BYTE(EOUTCSR1, ControlReg);
 356   1      
 357   1         if (Ep_Status[2] == EP_HALT)        // If endpoint is halted, send a stall
 358   1         {
 359   2            POLL_WRITE_BYTE(EOUTCSR1, rbOutSDSTL);
 360   2         }
 361   1      
 362   1         else                                // Otherwise read packet from host
 363   1         {
 364   2            if (ControlReg & rbOutSTSTL)     // Clear sent stall bit if last packet 
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 7   

 365   2                                             // was a stall
 366   2            {
 367   3               POLL_WRITE_BYTE(EOUTCSR1, rbOutCLRDT);
 368   3            }
 369   2      
 370   2            POLL_READ_BYTE(EOUTCNTL, Count);
 371   2            if (Count != EP2_PACKET_SIZE)    // If host did not send correct packet 
 372   2                                            // size, flush buffer
 373   2            {
 374   3               POLL_WRITE_BYTE(EOUTCNTL, rbOutFLUSH);
 375   3            }
 376   2            else                             // Otherwise get the data packet
 377   2            {
 378   3              //fNewData à 1 si réception de nouvelles données
 379   3              //fNewData = Fifo_Read(FIFO_EP2, EP2_PACKET_SIZE, (BYTE*)OUT_PACKET);
 380   3              fNewData = Fifo_Read(FIFO_EP2, EP2_PACKET_SIZE, Out_Packet);
 381   3            }
 382   2      
 383   2            POLL_WRITE_BYTE(EOUTCSR1, 0);    // Clear Out Packet ready bit
 384   2         }
 385   1      }
 386          
 387          //-----------------------------------------------------------------------------
 388          // Usb_Suspend
 389          //-----------------------------------------------------------------------------
 390          //
 391          // Return Value : None
 392          // Parameters   : None
 393          //
 394          // Enter suspend mode after suspend signalling is present on the bus
 395          //
 396          //-----------------------------------------------------------------------------
 397          
 398          void Usb_Suspend(void)
 399          {          
 400   1      /****  
 401   1         // Si le mode Suspend doit forcer l'état low power du micro
 402   1         P0MDIN  = 0x00;     // Port 0 configured as analog input
 403   1         P1MDIN  = 0x00;     // Port 1 configured as analog input
 404   1         P2MDIN  = 0x00;     // Port 2 configured as analog input
 405   1         P3MDIN  = 0x00;     // Port 3 configured as analog input
 406   1      
 407   1         ADC0CN &= ~0x80;    // Disable ADC0
 408   1         REF0CN  = 0x00;     // Disable voltage reference
 409   1      
 410   1         // Force l'oscillateur en mode suspendu
 411   1         OSCICN |= 0x20;     // Put oscillator 
 412   1      
 413   1         // Lorsque l'usb déclenche une interruption de type non-idle
 414   1         // l'oscillateur sort du mode suspendu et les instructions ci-dessous
 415   1         // vont être exécutée. Il s'agit dès lors de reconfigurer les ports 
 416   1         // et l'AD selon les besoins de notre application
 417   1      
 418   1         P0MDIN  = 0x..;     // Port 0 
 419   1         P1MDIN  = 0x..;     // Port 1 
 420   1         P2MDIN  = 0x..;     // Port 2 
 421   1         P3MDIN  = 0x..;     // Port 3 
 422   1      
 423   1         REF0CN  = 0x0E;     // Enable voltage reference VREF
 424   1         ADC0CN |= 0x80;     // Re-enable ADC
 425   1      ****/
 426   1      }
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 8   

 427          
 428          //-----------------------------------------------------------------------------
 429          // Usb_Resume
 430          //-----------------------------------------------------------------------------
 431          //
 432          // Return Value : None
 433          // Parameters   : None
 434          //
 435          // Resume normal USB operation
 436          //
 437          //-----------------------------------------------------------------------------
 438          
 439          void Usb_Resume(void)
 440          {
 441   1         volatile int k;
 442   1      
 443   1         k++;
 444   1         // Add code for resume
 445   1      }
 446          
 447          //*-----------------------------------------------------------------------------
 448          // Fifo_Read variante avec un flag qui indique que de nouvelles données ont été 
 449          //             reçues et qu'elles diffèrent de la précédentes réceptions 
 450          //-----------------------------------------------------------------------------
 451          //
 452          // Return Value : None
 453          // Parameters   :
 454          //                1) BYTE addr : target address
 455          //                2) unsigned int uNumBytes : number of bytes to unload
 456          //                3) BYTE * pData : read data destination
 457          //
 458          // Read from the selected endpoint FIFO
 459          //
 460          //-----------------------------------------------------------------------------
 461          
 462          bit Fifo_Read(BYTE addr, unsigned int uNumBytes, BYTE * pData)
 463          {
 464   1         //--- Variables locales ---------------------------------------------------- 
 465   1         int i;
 466   1         bit DataChange=0;   
 467   1         BYTE BufferData;
 468   1         //--------------------------------------------------------------------------
 469   1      
 470   1         if (uNumBytes)                         // Check if >0 bytes requested,
 471   1         {
 472   2            USB0ADR = (addr);                   // Set address
 473   2            USB0ADR |= 0xC0;                    // Set auto-read and initiate
 474   2                                                // first read
 475   2      
 476   2            // Unload <NumBytes> from the selected FIFO
 477   2            for(i=0;i<uNumBytes-1;i++)
 478   2            {
 479   3               while(USB0ADR & 0x80);           // Wait for BUSY->'0' (data ready)
 480   3             BufferData = USB0DAT;            // Copy data byte
 481   3      
 482   3               if (BufferData !=pData[i])       //Test si la donnée à changé
 483   3             {
 484   4                DataChange = 1;
 485   4               pData[i] = BufferData;
 486   4             }
 487   3            }
 488   2      
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 9   

 489   2            USB0ADR = 0;                        // Clear auto-read
 490   2      
 491   2      
 492   2            while(USB0ADR & 0x80);              // Wait for BUSY->'0' (data ready)
 493   2            BufferData = USB0DAT;               // Copy data byte
 494   2      
 495   2            //Test si la donnée à changé
 496   2            if (BufferData !=pData[i])          
 497   2            {
 498   3             DataChange = 1;
 499   3             pData[i] = BufferData;
 500   3            }
 501   2         }
 502   1      
 503   1         return DataChange;
 504   1      } //-------------------------------------------------------------------------*/ 
 505          
 506          //-----------------------------------------------------------------------------
 507          // Fifo_Write
 508          //-----------------------------------------------------------------------------
 509          //
 510          // Return Value : None
 511          // Parameters   :
 512          //                1) BYTE addr : target address
 513          //                2) unsigned int uNumBytes : number of bytes to unload
 514          //                3) BYTE * pData : location of source data
 515          //
 516          // Write to the selected endpoint FIFO
 517          //
 518          //-----------------------------------------------------------------------------
 519          
 520          void Fifo_Write(BYTE addr, unsigned int uNumBytes, BYTE * pData)
 521          {
 522   1         int i;
 523   1      
 524   1         // If >0 bytes requested,
 525   1         if (uNumBytes)
 526   1         {
 527   2            while(USB0ADR & 0x80);              // Wait for BUSY->'0'
 528   2                                                // (register available)
 529   2            USB0ADR = (addr);                   // Set address (mask out bits7-6)
 530   2      
 531   2            // Write <NumBytes> to the selected FIFO
 532   2            for(i=0;i<uNumBytes;i++)
 533   2            {
 534   3               USB0DAT = pData[i];
 535   3               while(USB0ADR & 0x80);           // Wait for BUSY->'0' (data ready)
 536   3            }
 537   2         }
 538   1      }
 539          
 540          //-----------------------------------------------------------------------------
 541          // Force_Stall
 542          //-----------------------------------------------------------------------------
 543          //
 544          // Return Value : None
 545          // Parameters   : None
 546          //
 547          // Force a procedural stall to be sent to the host
 548          //
 549          //-----------------------------------------------------------------------------
 550          
C51 COMPILER V8.12   F32X_USB_ISR                                                          06/12/2012 19:56:16 PAGE 10  

 551          void Force_Stall(void)
 552          {
 553   1         POLL_WRITE_BYTE(INDEX, 0);
 554   1         POLL_WRITE_BYTE(E0CSR, rbSDSTL);       // Set the send stall bit
 555   1         Ep_Status[0] = EP_STALL;               // Put the endpoint in stall status
 556   1      }
 557          
 558          //-----------------------------------------------------------------------------
 559          // Get_Report
 560          //-----------------------------------------------------------------------------
 561          //
 562          // Return Value : None
 563          // Parameters   : None
 564          //
 565          // HID class specific request - mandatory
 566          // return specified report - Input or Feature report
 567          //
 568          //-----------------------------------------------------------------------------
 569          
 570          // Report type definition
 571          #define HID_REP_INPUT      0x01
 572          #define HID_REP_OUTPUT     0x02
 573          #define HID_REP_FEATURE    0x03
 574          
 575          void Get_Report(void)
 576          {
 577   1                                          // return Input report 0
 578   1         if (  (Setup.wValue.c[MSB] == HID_REP_INPUT)
 579   1               && (Setup.wValue.c[LSB] == 0)          ) {
 580   2      
 581   2            //DataPtr  = IN_PACKET;
 582   2            DataPtr  = In_Packet; 
 583   2      
 584   2            DataSize = EP1_PACKET_SIZE;
 585   2      
 586   2            if ( Setup.wLength.i < DataSize )
 587   2               DataSize = Setup.wLength.i;         // Send only requested amount of data
 588   2      
 589   2            Ep_Status[0] = EP_TX;               // Put endpoint in transmit mode
 590   2            DataSent = 0;                    // Reset Data Sent counter
 591   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);      // Service Setup Packet
 592   2      
 593   2         } else
 594   1            Force_Stall();                   // Send stall to host if invalid request
 595   1      }
 596          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1164    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    128    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19      27
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
