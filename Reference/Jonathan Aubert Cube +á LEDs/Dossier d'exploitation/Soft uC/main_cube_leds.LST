C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE MAIN_CUBE_LEDS
OBJECT MODULE PLACED IN main_cube_leds.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main_cube_leds.c OPTIMIZE(3,SPEED) BROWSE INCDIR(.\Header;.\Lib) DEBUG OBJE
                    -CTEXTEND TABS(3)

line level    source

   1          /*===========================================================================*=
   2             
   3             CFP - Technique - Cube LEDs 3D
   4          
   5            -----------------------------------------------------------------------------                 
   6             Auteur        : Jonathan Aubert   
   7             Date création : 19 avril 2012
   8             Modifié le    : 4 juin 2012
   9             Version       : 1.0
  10            =============================================================================
  11             Descriptif: Application permettant le contrôle du cube via 3 boutons 
  12             poussoirs. Un menu défilant permet de sélectionner l'animation à afficher ou
  13             de passer en mode connection USB au PC. Une fois ce mode établi, les seuls 
  14             moyens de reprendre contrôle du cube sont soit de l'éteindre, soit de le 
  15             déconnecter via l'application PC. 
  16             
  17          =*===========================================================================*/
  18          
  19          //--- Includes ----------------------------------------------------------------
  20          #include <c8051f320.h>           
  21          #include "F32x_USB_Primitives.h" // firmware usb
  22          #include <stdlib.h>              // accès au générateur de nombre aléatoire
  23          #include "FONT5x7.c"             // police de caractères 5*7
  24          #include <string.h>              // manipulation de chaines de caractères
  25          
  26          
  27          //Structure pour définir/lire un point dans l'espace
  28          typedef struct
  29          {
  30             char x;
  31             char y;
  32             char z;
  33          } coord;
  34          
  35                                                          
  36          //Structure de bits pour flags (pour flags menu par exemple)         
  37          typedef struct
  38          {
  39             unsigned int bit_0 : 1;
  40             unsigned int bit_1 : 1;
  41             unsigned int bit_2 : 1;
  42             unsigned int bit_3 : 1;
  43             unsigned int bit_4 : 1;
  44             unsigned int bit_5 : 1;
  45             unsigned int bit_6 : 1;
  46             unsigned int bit_7 : 1;
  47             unsigned int bit_8 : 1;
  48             unsigned int bit_9 : 1;
  49             unsigned int bit_10 : 1;
  50             unsigned int bit_11 : 1;
  51             unsigned int bit_12 : 1;
  52             unsigned int bit_13 : 1;
  53             unsigned int bit_14 : 1;
  54             unsigned int bit_15 : 1;
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 2   

  55             unsigned int bit_16 : 1;
  56          } bit_st;
  57          
  58          // ==== Fonctions prototypes ==================================================
  59          void Port_Init();          // Configure ports
  60          void SPIInit ();           // init config SPI
  61          void PCA0_Init();          // init du PCA0
  62          void Init_Int0();          // init INT0
  63          void Init_Int1();          // init INT1
  64          void Init_Timer0();        // init Timer0
  65          void luminosite(unsigned char lum);
  66          void Cube_car(unsigned char ptr_newcube[][8],unsigned char face_nb ,
  67                                                                            char caract);
  68          void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb);
  69          void anim_base_l_r(unsigned char ptr_newcube[][8], bit new);
  70          void anim_base_up_dn(unsigned char ptr_newcube[][8], bit new);
  71          void anim_base_up(unsigned char ptr_newcube[][8]);
  72          void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], 
  73                                                                               bit sens);
  74          void Depl_profond(unsigned char ptr_newcube[][8], bit sens);
  75          void Depl_largeur(unsigned char ptr_newcube[][8], bit sens);
  76          void Depl_hauteur(unsigned char ptr_newcube[][8], bit sens);
  77          void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],
  78                                                                   unsigned char face_nb);
  79          void tabtolayer(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],
  80                                                                   unsigned char etage_nb);
  81          void Copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
  82          void Clear_cube(unsigned char tab[][8]);
  83          void Or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
  84          void Wr_coord_cube(coord *ptr_coord,bit state,unsigned char ptr_tab[][8]);
  85          bit Rd_coord_cube(coord *ptr_coord,unsigned char ptr_tab[][8]);
  86          void Tab_to_use(unsigned char working_add[][8],unsigned char ptrbuff1[][8],
  87                                                          unsigned char ptrbuff2[][8]);
  88          
  89          
  90          // ==== Equivalences ==========================================================
  91          #define TIMER0_LOAD 60512     //Délai pour 10ms (Tinc = 2 [us]).
  92          #define CEX0_XBR_BIT 0x01     //bit pour router le CEX0 au port (P0.3 dans ce cas).
  93          #define PCA0CN_ACT_BIT 0x40   //bit d'activation du PCA0 (PWM dans ce cas).
  94          #define PCA0CPM0_ECOM_BIT 0x40//bit d'activation du comparateur module 0
  95          
  96          #define MENU_SIZE 6           //Taille du menu principal
  97          
  98          #define LUM_DEFAULT 100    //Luminosité du cube par défaut
  99          
 100          #define USB_MODE_NULL 0    //Si rien est à faire avec le case de l'usb
 101          #define USB_MODE_DRAW 1    //pour le case de l'usb, mode dessin
 102          #define USB_MODE_PWM 2     //pour le case de l'usb, mode PWM (luminosité leds)
 103          
 104          // ==== Variables globales ====================================================
 105          code char anim_layer_on[] =   {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 106          code char chiffre_0 [] =      {0x3C,0x42,0x5A,0x42,0x66,0x5A,0x42,0x3C};
 107          code char chiffre_1 [] =      {0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x7E};
 108          code char chiffre_2 [] =      {0x3C,0x42,0x02,0x04,0x08,0x10,0x20,0x7E};
 109          code char chiffre_3 [] =      {0x3C,0x42,0x02,0x0E,0x0E,0x02,0x42,0x3C};
 110          code char chiffre_4 [] =      {0x04,0x08,0x10,0x28,0x48,0x7E,0x08,0x08};
 111          code char logo_usb [] =       {0x00,0xC3,0xA4,0xA4,0xC4,0x84,0x83,0x00};
 112          
 113          
 114          //Trames échangées 
 115          code char str_usb_rdy[] = "#ready$";         //Trame cube prêt!
 116          code char str_usb_notdry[] = "#notready$";   //Trame cube non-prêt
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 3   

 117          code char str_usb_pwm[] = "#pwm$";     //Trame de réception PWM
 118          code char str_usb_draw[] = "#draw$";   //Trame de réception image va être reçu
 119          code char str_usb_stop[] = "#stop$";   //trame à recevoirde mode stop
 120          
 121          xdata unsigned char (*ptrledcube)[8];  //ptr pour mémoire du cube!
 122          //démarrage sur le tableau 1 (si à 0, ce sera le tableau 2)!
 123          bit flag_buffcube1 = 1; 
 124          xdata unsigned char layer_cube = 0;
 125          xdata unsigned char pwm_prechg = 0xFF; //valeur du registre du pwm
 126          xdata unsigned long time_global = 0;
 127          
 128          bit flag_pca_cmp_act = 0;  //le cmp du module 0 PCA0 est désactivé de base 
 129          bit memory_lock = 0;                   //indique si mémoire occupée
 130          
 131          //FLAG à 1 indique un appui  (gestion à 1 si autorisée)
 132          bit btn_ok = 0, btn_prec = 0, btn_suiv = 0, flag_gestion_btn = 1; 
 133          
 134          
 135          sbit Micrel_strb = P0^3;
 136          sbit Micrel_out_en = P1^1;
 137          sbit Clk_layer = P0^6;
 138          sbit L0_detect = P1^0;
 139          sbit Sw_prec = P1^2;
 140          sbit Sw_ok = P1^3;
 141          sbit Sw_suiv = P1^4;
 142          
 143          
 144          
 145          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
 146          /*                                  MAIN                                     */
 147          /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
 148          void main(void)
 149          {
 150   1         //--- Variables locales ----------------------------------------------------
 151   1         //Variables utilisées pour affichage
 152   1         xdata unsigned char cube_buffer1 [8][8];     
 153   1         xdata unsigned char cube_buffer2 [8][8];     
 154   1         //Tableau à utiliser comme buffer
 155   1         xdata unsigned char (*buff_to_use)[8] = cube_buffer1; 
 156   1         //==========================================================================
 157   1      
 158   1         //Buffer supplémentaire pour calculer de nouvelles images (exemple rotation)
 159   1         xdata unsigned char cube_buff3 [8][8]; 
 160   1      
 161   1         //pour définir un point dans l'espace avec les fonctions Wr/Rd_coord_cube
 162   1         xdata coord coordpt; 
 163   1         xdata unsigned char luminosite_buff = 100;   //buffer pour luminosité cube
 164   1         xdata unsigned char i = 0, j = 0;            //Compteurs
 165   1      
 166   1         //Pour la gestion du menu principale
 167   1         xdata unsigned char menu = 0;    //indique le n° du menu sélectionné
 168   1         //flags Utilisés pour la gestion du menu et boutons
 169   1         bit run_anim = 0, new_menu = 1, sens_anim_3 = 1;   
 170   1         //Initialisation des flags premier passage menu à 1
 171   1         xdata bit_st first_menu = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};   
 172   1      
 173   1         //Pour la gestion usb!
 174   1         //Type de mode usb (Réception image, luminosité etc...)
 175   1         xdata unsigned char mode_usb = 0;   
 176   1         bit usb_mode = 0;    //A 1 si mode usb sélectionnée
 177   1         bit first_usb = 1;   //Indique si c'est le premier passage en mode usb
 178   1         
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 4   

 179   1         //--------------------------------------------------------------------------
 180   1      
 181   1         PCA0MD &= ~0x40;  // Disable Watchdog timer
 182   1         Sysclk_Init();    // Initialize oscillator inclus spécificité usb
 183   1                           // Clock système sera fixé à 24MHz
 184   1         Port_Init();      // Initialize crossbar and GPIO
 185   1         SPIInit ();       // init config SPI
 186   1         Init_Timer0();    // init Timer0
 187   1         PCA0_Init();      // Initialisation du PCA0
 188   1         Init_Int0();      // init INT0 
 189   1         Init_Int1();
 190   1         Usb0_Init();   // Initialize USB0 (Doit être la dernière routine init car
 191   1                        // autorisation générale de interrupt fait à un moment opportun
 192   1                        // dans cette routine) 
 193   1      
 194   1         while(memory_lock);  //Attendre libération de la mémoire avant de continuer
 195   1         ptrledcube = cube_buffer1; //passage du pointeur sur cube_buffer1
 196   1      
 197   1      
 198   1         Micrel_out_en = 1;   //Inhibition des sorties drivers au démarrage
 199   1         Micrel_strb = 0;
 200   1      
 201   1             
 202   1         //Envoi : 0 par usb 
 203   1         for (i=0;i<64;i++)
 204   1            SendDataBuffer[i] = 0x00;                 
 205   1         Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 
 206   1      
 207   1         EX0 = 1; //Autorise l'interruption INT0 pour démarrage de synchronisation cube!    
 208   1         TR0 = 1; //Démarrage du timer0
 209   1      
 210   1      
 211   1         Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2); //choix du buffer à utiliser
 212   1         Clear_cube(buff_to_use);      //effacement du tableau libre          
 213   1         while(memory_lock);     //Attendre libération de la mémoire avant de continuer
 214   1         ptrledcube = buff_to_use;  //passage du pointeur sur le buffer utilisé
 215   1         flag_buffcube1^=1;         //Le buffer n'est plus le même
 216   1      
 217   1         while (1)
 218   1         {
 219   2      
 220   2            //============ gestion du menu selon les données des bouton =============
 221   2            if (flag_gestion_btn)   //Si la gestion des boutons est autorisée
 222   2            {
 223   3               if (btn_ok)          //Si flag touche de confirmation appuyée,
 224   3               {
 225   4                  btn_ok = 0;    //raz du flag
 226   4                  //l'animation en cours de sélection va être lancée ou arrêtée
 227   4                  run_anim ^= 1; 
 228   4                  if(!run_anim)  //Dans le cas d'un arrêt, actualisation du menu
 229   4                  {
 230   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.   
 231   5                     //La luminosité du cube revient à sa valeur par defaut
 232   5                     luminosite(LUM_DEFAULT);   
 233   5                  }
 234   4               }
 235   3               
 236   3               if (btn_suiv)  //Sinon, si c'est une simple sélection d'anim suivante.
 237   3               {
 238   4                  btn_suiv = 0;  //raz flag
 239   4                  if (run_anim)
 240   4                  {
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 5   

 241   5                     //La luminosité du cube revient à sa valeur par defaut
 242   5                     luminosite(LUM_DEFAULT);   
 243   5                     run_anim = 0;     //l'animation sera stopée, retour à la sélection
 244   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.
 245   5                  }  
 246   4                  else
 247   4                  {
 248   5                     //incrémentation de la sélection d'anim dans le menu
 249   5                     menu = (menu+1)%MENU_SIZE; 
 250   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.
 251   5                  }
 252   4               }
 253   3               //Sinon, si c'est une simple sélection anim précédente.
 254   3               else if (btn_prec)   
 255   3               {
 256   4                  btn_prec = 0;  //raz flag
 257   4         
 258   4                  if (run_anim)
 259   4                  {
 260   5                     //La luminosité du cube revient à sa valeur par defaut
 261   5                     luminosite(LUM_DEFAULT);   
 262   5                     run_anim = 0;     //l'animation sera stopée, retour à la sélection
 263   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.
 264   5                  }  
 265   4                  else if (menu)    //Si le menu n'est pas encore à 0
 266   4                  {
 267   5                     //décrémentation de la sélection d'anim dans le menu
 268   5                     menu = (menu-1)%MENU_SIZE; 
 269   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.
 270   5                  }
 271   4                  else           //Sinon (menu à 0)
 272   4                  {
 273   5                     menu = MENU_SIZE-1;  //Le menu prend la valeur max
 274   5                     new_menu = 1;  //Flag de rafraichissement menu à 1.
 275   5                  }
 276   4               }
 277   3            }
 278   2            //====================== Fin gestion du menu ============================
 279   2      
 280   2      
 281   2      
 282   2      
 283   2      
 284   2            //=========================Affichage du menu=============================
 285   2      
 286   2            if (run_anim)  //Si décision de lancement de l'animation
 287   2            {
 288   3               
 289   3               switch(menu)   //selon le menu sélectionné
 290   3               {
 291   4                  case 0:
 292   4      
 293   4                     if(time_global>=80)  //Si 80ms écoulées   
 294   4                     {
 295   5                        time_global = 0;  //RAZ du time pour timing  
 296   5                        //choix du buffer à utiliser
 297   5                        Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);    
 298   5                        if (first_menu.bit_0)   //Si première entrée dans l'anim,
 299   5                        {
 300   6                           Clear_cube(buff_to_use);   //Le cube est off
 301   6                        }     
 302   5                        anim_base_up(buff_to_use); //animation de base montante!
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 6   

 303   5                        //Attendre libération de la mémoire avant de continuer
 304   5                        while(memory_lock);        
 305   5                        //passage du pointeur sur le nouveau utilisé
 306   5                        ptrledcube = buff_to_use;  
 307   5                        flag_buffcube1^=1;   //Avertissement de changement de buffer
 308   5                     }
 309   4      
 310   4                  break;
 311   4         
 312   4                  case 1:
 313   4      
 314   4                     if(time_global>=80)  //Si 80ms écoulées   
 315   4                     {
 316   5                        time_global = 0;  //RAZ du time pour timing
 317   5                        //choix du buffer à utiliser
 318   5                        Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);        
 319   5                        if (first_menu.bit_1)   //Si c'est la première image de l'anim,
 320   5                        {
 321   6                           Clear_cube(buff_to_use);                  //efface le cube  
 322   6                           //Copie de la couche à afficher sur l'étage 0                  
 323   6                           tabtolayer(anim_layer_on,buff_to_use,0);  
 324   6                           anim_base_up_dn(buff_to_use, first_menu.bit_1); //new anim
 325   6                           //les prochaines images ne seront pas la première
 326   6                           first_menu.bit_1 = 0;                           
 327   6                        }
 328   5                        else
 329   5                        {
 330   6                           //animation de base up/dn!
 331   6                           anim_base_up_dn(buff_to_use, first_menu.bit_1); 
 332   6                        }
 333   5                     
 334   5                        //Attendre libération de la mémoire avant de continuer
 335   5                        while(memory_lock);     
 336   5                        //passage du pointeur sur le nouveau utilisé    
 337   5                        ptrledcube = buff_to_use;     
 338   5                        //Avertissement de changement de buffer
 339   5                        flag_buffcube1^=1;            
 340   5                     }
 341   4                  break;
 342   4                  case 2:
 343   4                     if(time_global>=80)  //Si 80ms écoulées   
 344   4                     {
 345   5                        time_global = 0;  //RAZ du time pour timing
 346   5                        //choix du buffer à utiliser
 347   5                        Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);       
 348   5                        if (first_menu.bit_2)
 349   5                        {
 350   6                           Clear_cube(buff_to_use);   //Efface le cube
 351   6                           Clear_cube(cube_buff3);    //efface le cube_buff3
 352   6                           //Copie du tableau à afficher sur la face 0                    
 353   6                           tabtoface(anim_layer_on,cube_buff3,0);    
 354   6                           //rotation de l'image à gauche (90°)
 355   6                           rotat_h(cube_buff3,buff_to_use,1);     
 356   6                           anim_base_l_r(buff_to_use,first_menu.bit_2); //Nouvelle anim
 357   6                           //les prochaines images ne seront pas la première
 358   6                           first_menu.bit_2 = 0;         
 359   6                        }
 360   5                        else
 361   5                        {
 362   6                           anim_base_l_r(buff_to_use,first_menu.bit_2); //Animation
 363   6                        }
 364   5                        //Attendre libération de la mémoire avant de continuer
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 7   

 365   5                        while(memory_lock);     
 366   5                        //passage du pointeur sur le nouveau utilisé
 367   5                        ptrledcube = buff_to_use;  
 368   5                        flag_buffcube1^=1;      //Avertissement de changement de buffer
 369   5                     }
 370   4      
 371   4                  break;
 372   4                  case 3:
 373   4                  if (first_menu.bit_3)      //Si c'est le premier lancement du menu 3,
 374   4                  {
 375   5                     first_menu.bit_3 = 0;   //RAZ du flag
 376   5                     luminosite_buff = 70;   //Luminosité de départ à 70
 377   5      
 378   5                     //choix du buffer à utiliser
 379   5                     Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);       
 380   5                        
 381   5                     for(i=0;i<8;i++)        //allumage des 8 étages
 382   5                     {
 383   6                        for(j=0;j<8;j++)
 384   6                        {
 385   7                           buff_to_use[j][i] = 0xFF;  //Allumage du cube entier        
 386   7                        }  
 387   6                     }
 388   5                     //Attendre libération de la mémoire avant de continuer                  
 389   5                     while(memory_lock);  
 390   5                     //passage du pointeur sur le nouveau utilisé
 391   5                     ptrledcube = buff_to_use;  
 392   5                     //Avertissement de changement de buffer
 393   5                     flag_buffcube1^=1;                  
 394   5                  }
 395   4                  else
 396   4                  {
 397   5                     if(time_global>=20)  //Si 20ms écoulées   
 398   5                     {
 399   6                        time_global = 0;  //RAZ du time pour timing
 400   6                        luminosite(luminosite_buff);  //réglage de la luminosité
 401   6      
 402   6                        //mécanisme d'auto incrémentation/décrémentation
 403   6                        if(luminosite_buff >= 70)     
 404   6                           sens_anim_3 = 0;
 405   6                        else if (luminosite_buff==0) 
 406   6                           sens_anim_3 = 1;
 407   6                        
 408   6                        if (sens_anim_3)  
 409   6                           luminosite_buff++;
 410   6                        else
 411   6                           luminosite_buff--;
 412   6                     }  
 413   5                  }     
 414   4                  break;
 415   4                  case 4:
 416   4                     if(time_global>=100) //Si 100ms écoulées  
 417   4                     {
 418   5                        time_global = 0;  //RAZ du time pour timing
 419   5                        //choix du buffer à utiliser  
 420   5                        Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);    
 421   5                        if (first_menu.bit_4)   //Si première entrée dans le menu,
 422   5                        {
 423   6                           Clear_cube(buff_to_use);               //Efface le cube
 424   6                           //les prochaines images ne seront pas la première
 425   6                           first_menu.bit_4 = 0;      
 426   6                        }
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 8   

 427   5                        anim_pluie(buff_to_use,2); //Animation pluie n°2
 428   5                        
 429   5                        //Attendre libération de la mémoire avant de continuer
 430   5                        while(memory_lock);  
 431   5                        //passage du pointeur sur le nouveau utilisé    
 432   5                        ptrledcube = buff_to_use;  
 433   5                        flag_buffcube1^=1;   //Avertissement de changement de buffer
 434   5                     }
 435   4                  break;
 436   4                  case 5:
 437   4                     if(!usb_mode)        //Si pas le mode usb n'est pas encore actif,
 438   4                     {
 439   5                        //choix du buffer à utiliser
 440   5                        Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);          
 441   5                        Clear_cube(buff_to_use);      //Efface le cube
 442   5                        Cube_car(buff_to_use,7, 'D'); //Affiche Data en profondeur
 443   5                        Cube_car(buff_to_use,5, 'A');
 444   5                        Cube_car(buff_to_use,3, 'T'); 
 445   5                        Cube_car(buff_to_use,1, 'A');
 446   5                  //Déplacement du cube d'1 led sur à droite (centrage des caractères)
 447   5                        Depl_largeur(buff_to_use,1);
 448   5                        //Attendre libération de la mémoire avant de continuer
 449   5                        while(memory_lock);        
 450   5                        //passage du pointeur sur le nouveau utilisé
 451   5                        ptrledcube = buff_to_use;  
 452   5                        //Avertissement de changement de buffer
 453   5                        flag_buffcube1^=1;         
 454   5                        usb_mode = 1;     //Activation du mode USB
 455   5                     }
 456   4                  break;         
 457   4               }
 458   3            }
 459   2            else if (new_menu)            //Sinon, si Menu de sélection!!!!!!!!!!!!!!  
 460   2            {
 461   3               first_menu.bit_0 = 1;   //RA1 des flag de gestion pour premier passage
 462   3               first_menu.bit_1 = 1;   //dans le mode runanimation
 463   3               first_menu.bit_2 = 1;
 464   3               first_menu.bit_3 = 1;
 465   3               first_menu.bit_4 = 1;
 466   3               first_menu.bit_5 = 1;
 467   3      
 468   3               //choix du buffer à utiliser
 469   3               Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);    
 470   3               Clear_cube(buff_to_use);   //Clear le buffer
 471   3      
 472   3               switch(menu)   //selon le menu sélectionné
 473   3               {        
 474   4                  case 0:  
 475   4      
 476   4                     tabtoface(chiffre_0,buff_to_use,3); //Copie du chiffre à afficher
 477   4                     tabtoface(chiffre_0,buff_to_use,4); //Sur les faces 2 et 3
 478   4                     //Attendre libération de la mémoire avant de continuer
 479   4                     while(memory_lock);        
 480   4                     //passage du pointeur sur le buffer utilisé
 481   4                     ptrledcube = buff_to_use;  
 482   4                     //Le buffer n'est plus le même
 483   4                     flag_buffcube1^=1;       
 484   4                                    
 485   4                  break;
 486   4         
 487   4                  case 1:
 488   4               
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 9   

 489   4                     tabtoface(chiffre_1,buff_to_use,3); //Copie du chiffre à afficher
 490   4                     tabtoface(chiffre_1,buff_to_use,4); //Sur les faces 2 et 3
 491   4                     //Attendre libération de la mémoire avant de continuer
 492   4                     while(memory_lock);     
 493   4                     //passage du pointeur sur le buffer utilisé  
 494   4                     ptrledcube = buff_to_use;
 495   4                     //Le buffer n'est plus le même   
 496   4                     flag_buffcube1^=1;         
 497   4                           
 498   4                  break;
 499   4                  case 2:
 500   4      
 501   4                     tabtoface(chiffre_2,buff_to_use,3); //Copie du chiffre à afficher
 502   4                     tabtoface(chiffre_2,buff_to_use,4); //Sur les faces 2 et 3
 503   4                     //Attendre libération de la mémoire avant de continuer
 504   4                     while(memory_lock);     
 505   4                     //passage du pointeur sur le buffer utilisé  
 506   4                     ptrledcube = buff_to_use;  
 507   4                     //Le buffer n'est plus le même
 508   4                     flag_buffcube1^=1;         
 509   4      
 510   4                  break;
 511   4                  case 3:
 512   4      
 513   4                     tabtoface(chiffre_3,buff_to_use,3); //Copie du chiffre à afficher
 514   4                     tabtoface(chiffre_3,buff_to_use,4);  //Sur les faces 2 et 3
 515   4                     //Attendre libération de la mémoire avant de continuer
 516   4                     while(memory_lock);        
 517   4                     //passage du pointeur sur le buffer utilisé
 518   4                     ptrledcube = buff_to_use;  
 519   4                     //Le buffer n'est plus le même
 520   4                     flag_buffcube1^=1;         
 521   4      
 522   4                  break;
 523   4                  case 4:
 524   4      
 525   4                     tabtoface(chiffre_4,buff_to_use,3); //Copie du chiffre à afficher 
 526   4                     tabtoface(chiffre_4,buff_to_use,4); //Sur les faces 2 et 3
 527   4                     //Attendre libération de la mémoire avant de continuer
 528   4                     while(memory_lock);        
 529   4                     //passage du pointeur sur le buffer utilisé
 530   4                     ptrledcube = buff_to_use;
 531   4                     //Le buffer n'est plus le même   
 532   4                     flag_buffcube1^=1;         
 533   4      
 534   4                  break;
 535   4                  case 5:
 536   4      
 537   4                     tabtoface(logo_usb,buff_to_use,3);  //Copie du chiffre à afficher
 538   4                     tabtoface(logo_usb,buff_to_use,4);  //Sur les faces 2 et 3
 539   4                     //Attendre libération de la mémoire avant de continuer
 540   4                     while(memory_lock);     
 541   4                     //passage du pointeur sur le buffer utilisé  
 542   4                     ptrledcube = buff_to_use;  
 543   4                     //Le buffer n'est plus le même
 544   4                     flag_buffcube1^=1;         
 545   4                              
 546   4                  break;         
 547   4               }
 548   3               new_menu = 0;  //Le flag de rafraichissement du menu est raz.
 549   3            }
 550   2      
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 10  

 551   2            //========================Fin de l'affichage du menu=====================
 552   2      
 553   2      
 554   2      
 555   2      
 556   2      
 557   2      
 558   2      
 559   2      
 560   2            //========================Pour sélection du mode usb=====================
 561   2                
 562   2            if (usb_mode)        //Si le mode usb est sélectionnée
 563   2            {
 564   3               //impossibilité de toucher les boutons jusqu'à nouvel ordre!
 565   3               flag_gestion_btn = 0;   
 566   3      
 567   3               if(first_usb)     //Si c'est le premier dialogue par usb
 568   3               {
 569   4                  //copie du message usb prêt dans le buffer usb  
 570   4                  strcpy(SendDataBuffer,str_usb_rdy);    
 571   4                  //Envoi : cube_prêt à recevoir des données
 572   4                  Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer));    
 573   4                  first_usb = 0;
 574   4               }
 575   3                  
 576   3                
 577   3               if (fNewData)           //Si de nouvelles données sont reçues
 578   3               {  
 579   4                  //Acquistion des données
 580   4                  Read_receive_Packet(ReceiveDataBuffer, sizeof(ReceiveDataBuffer));
 581   4         
 582   4                  j = ReceiveDataBuffer[0];
 583   4      
 584   4                  if (mode_usb == USB_MODE_NULL)   //Si aucun ordre actuel,
 585   4                  {
 586   5                     //Si trame de mode dessin reçue,
 587   5                     if (!strcmp(str_usb_draw,ReceiveDataBuffer)) 
 588   5                     {
 589   6                        mode_usb = USB_MODE_DRAW;  //mode de dessin activé 
 590   6                     }
 591   5                     //Sinon, si une luminositée va être reçue
 592   5                     else if (!strcmp(str_usb_pwm,ReceiveDataBuffer))   
 593   5                     {
 594   6                        mode_usb = USB_MODE_PWM;   //Accès au pwm
 595   6                     }
 596   5               //Sinon, si trame de stop usb reçue (et que la fin de trame est bien à 0)
 597   5                     else if (!strcmp(str_usb_stop,ReceiveDataBuffer))     
 598   5                     {
 599   6                        //Copie de trame not ready dans le buffer d'envoi usb 
 600   6                        strcpy(SendDataBuffer,str_usb_notdry);       
 601   6                        //Envoi : cube pas prêt à recevoir des données
 602   6                        Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 
 603   6                        mode_usb = USB_MODE_NULL;  //plus rien à faire dans le case
 604   6                        //La luminosité revient à la valeur par défaut
 605   6                        luminosite_buff = LUM_DEFAULT;   
 606   6                        luminosite(luminosite_buff);  //Réglage de la nouvelle luminosité
 607   6                        first_usb = 1; //en cas de nouvel communication 
 608   6                        usb_mode = 0;  //le mode usb est quitté
 609   6                        new_menu = 1;  //retour au menu de sélection
 610   6                        run_anim = 0;  //retour au menu de sélection
 611   6                        //Communication usb terminée, réacivation des boutons 
 612   6                        flag_gestion_btn = 1;      
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 11  

 613   6                     }
 614   5                  }
 615   4                  else     //Sinon, la donnée reçue est de type donnée à 
 616   4                  {        //afficher ou nouvelle luminosité,
 617   5                     switch(mode_usb)  //Selon le mode usb choisi via l'application C#,
 618   5                     {
 619   6                        case USB_MODE_DRAW: 
 620   6                           //choix du buffer à utiliser  
 621   6                           Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);    
 622   6                        
 623   6                           for (i=0;i<8;i++)
 624   6                           {
 625   7                              for (j=0;j<8;j++)
 626   7                              {           
 627   8                        //transfert du buffer de réception usb dans le mémoire buffer           
 628   8                                 buff_to_use[j][i] = ReceiveDataBuffer[(i*8)+j]; 
 629   8                              }
 630   7                           }
 631   6         
 632   6                           //Attendre libération de la mémoire avant de continuer 
 633   6                           while(memory_lock);     
 634   6                           //passage du pointeur sur le nouveau utilisé
 635   6                           ptrledcube = buff_to_use;  
 636   6                           //Avertissement de changement de buffer
 637   6                           flag_buffcube1^=1;      
 638   6                     //IL n'y aura plus rien à faire dans le case avant autre commande
 639   6                           mode_usb = USB_MODE_NULL;  
 640   6                        break;
 641   6      
 642   6                        case USB_MODE_PWM:   //En cas de PWM à recevoir
 643   6      
 644   6                           luminosite_buff = 0;
 645   6                           luminosite_buff += (ReceiveDataBuffer[0]-'0')*100;
 646   6                           luminosite_buff += (ReceiveDataBuffer[1]-'0')*10;
 647   6                           luminosite_buff += ReceiveDataBuffer[2]-'0';
 648   6                           //Enregistrement de la valeur reçue
 649   6                           //Réglage de la nouvelle luminosité
 650   6                           luminosite(luminosite_buff);  
 651   6                             
 652   6                           mode_usb = USB_MODE_NULL;  //Plus rien à faire dans le case
 653   6                        break;
 654   6                     }
 655   5                  }
 656   4                  fNewData = 0; //Quittance la lecture des nouvelles données  
 657   4               }  
 658   3            }   
 659   2      
 660   2            //========================= Fin du mode USB =============================
 661   2      
 662   2           
 663   2         } //--- End while (1)
 664   1      
 665   1      }/*%%%%%%%%%%%%%%%%%%%%%%%%%%%% END MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
*** WARNING C280 IN LINE 162 OF MAIN_CUBE_LEDS.C: 'coordpt': unreferenced local variable
 666          
 667          /*---------------------------------------------------------------------------*-
 668             Port_Init ()
 669            -----------------------------------------------------------------------------
 670             Descriptif: Initialisation du mode de fonctionnement des ports 
 671             Entrée    : --
 672             Sortie    : --
 673          -*---------------------------------------------------------------------------*/
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 12  

 674          void Port_Init () 
 675          {
 676   1      
 677   1         // P0.0  -  SCK  (SPI0), Push-Pull,  Digital
 678   1         // P0.1  -  MISO (SPI0), Open-Drain, Digital
 679   1         // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
 680   1         // P0.3  -  Skipped,     Push-Pull,  Digital
 681   1         // P0.4  -  Skipped,     Open-Drain, Digital
 682   1         // P0.5  -  Skipped,     Open-Drain, Digital
 683   1         // P0.6  -  Skipped,     Open-Drain, Digital
 684   1         // P0.7  -  Skipped,     Open-Drain, Digital
 685   1         
 686   1         // P1.0  -  Skipped,     Open-Drain, Digital
 687   1         // P1.1  -  [CEX0 (PCA)],  Push-Pull,  Digital
 688   1         // P1.2  -  Skipped,     Open-Drain, Digital
 689   1         // P1.3  -  Skipped,     Open-Drain, Digital
 690   1         // P1.4  -  Skipped,     Open-Drain, Digital
 691   1         // P1.5  -  Unassigned,  Open-Drain, Digital
 692   1         // P1.6  -  Unassigned,  Open-Drain, Digital
 693   1         // P1.7  -  Unassigned,  Open-Drain, Digital
 694   1         // P2.0  -  Unassigned,  Open-Drain, Digital
 695   1         // P2.1  -  Unassigned,  Open-Drain, Digital
 696   1         // P2.2  -  Unassigned,  Open-Drain, Digital
 697   1         // P2.3  -  Unassigned,  Open-Drain, Digital
 698   1      
 699   1      // MICREL_PINS (P0.0 (SCK)), (P0.2 (MOSI)),(P0.3(Micrel_strb)) en push-pull, 
 700   1      // MIS0 (P0.1), Clk_layer (P0.6) et btn_detect (P0.7) en open drain  
 701   1         P0MDOUT = 0x0D;      
 702   1         P0SKIP = 0xF8;       // Skip P0
 703   1      
 704   1         P1MDOUT = 0x02;      // port P1 en open drain sauf Micrel_out_en (P1.1)
 705   1         P1SKIP  = 0x1D;      // skip port P1                                                              
 706   1      
 707   1         XBR0 |= 0x02;        // autorise le SPI 
 708   1         XBR1   |= 0x40;      // autorise le fonctionnement du crossbar 
 709   1      
 710   1      } // Port_Init -----------------------------------------------------------------
 711          
 712          
 713          /*---------------------------------------------------------------------------*-
 714             SPIInit ()
 715            -----------------------------------------------------------------------------
 716             Descriptif: Initialisation du mode de fonctionnement du bus SPI
 717          
 718                - mode maître
 719                - clock = 3 MHz
 720                - clock au repos à '0' et actif sur le flanc montant 
 721                - mode 4 fils en maître unique
 722          
 723             Entrée    : --
 724             Sortie    : --
 725          -*---------------------------------------------------------------------------*/
 726          void SPIInit () 
 727          {
 728   1                           //  +------------  x (read only)
 729   1                           //  ¦+-----------  mode : 1 = mode Master
 730   1                           //  ¦¦+----------  phase du SCK  : 0 = flanc montant
 731   1                           //  ¦¦¦+---------  SCK au repos  : 0 = niveau bas
 732   1                           //  ¦¦¦¦   +-----  x (read only)
 733   1                           //  ¦¦¦¦   ¦+----  x (read only)
 734   1                           //  ¦¦¦¦   ¦¦+---  x (read only)
 735   1                           //  ¦¦¦¦   ¦¦¦+--  x (read only)
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 13  

 736   1                           //  ¦¦¦¦   ¦¦¦¦
 737   1         SPI0CFG = 0x40;   //  0100 / 0000  
 738   1      
 739   1                           //  +------------  RAZ : flag SPIF
 740   1                           //  ¦+-----------  RAZ : flag WCOL
 741   1                           //  ¦¦+----------  RAZ : flag MODF
 742   1                           //  ¦¦¦+---------  RAZ : flag RXOVRN
 743   1                           //  ¦¦¦¦   +-----  NSSMD1 : mode 3 fils un seul maître  
 744   1                           //  ¦¦¦¦   ¦+----  NSSMD0 : X
 745   1                           //  ¦¦¦¦   ¦¦+---  RAZ : FLAG TXBMT
 746   1                           //  ¦¦¦¦   ¦¦¦+--  SPIEN : autorisation du SPI
 747   1                           //  ¦¦¦¦   ¦¦¦¦
 748   1         SPI0CN = 0x01;    //  0000 / 0001  
 749   1      
 750   1      
 751   1         SPI0CKR = 3;      // SPI0CKR = (SYSCLK/(2*CLK_SPI))-1
 752   1                           //           (24MHz/(2*(3MHz))-1 = 3    
 753   1         ESPI0=1;  //Autorisation des interruptions SPI
 754   1      } // SPIInit ------------------------------------------------------------------      
 755          
 756          
 757          /*---------------------------------------------------------------------------*-
 758             PCA0_Init ()
 759            -----------------------------------------------------------------------------
 760             Descriptif: Initialisation du PCA0 en mode PWM 8bits
 761             Entrée    : --
 762             Sortie    : --
 763          -*---------------------------------------------------------------------------*/
 764          void PCA0_Init()
 765          {
 766   1          PCA0CPM0  = 0x42;   //PCA en mode PWM 8bits    
 767   1          PCA0CPH0  = 0xFF;   //valeur de préchargement = MAX
 768   1      } // PCA0_Init ----------------------------------------------------------------      
 769          
 770          
 771          
 772          /*---------------------------------------------------------------------------*-
 773          Init_int0()
 774          -----------------------------------------------------------------------------
 775          Descriptif: Initialisation de l'interruption INT0 sur bit 6 port 0 actif sur 
 776          transition montante (Pour clock_800Hz). Priorité élevée pour contrer l'USB!
 777          Entrée : --
 778          Sortie : --
 779          -*---------------------------------------------------------------------------*/
 780          void Init_Int0()
 781          {
 782   1      
 783   1         //-- Démarrage de la configuration pour INT0 --
 784   1         EX0 = 0;             // Inhibe l'interruption INT0
 785   1         //-- Matériel --
 786   1         IT0 = 1;             // Interruption actif sur transition.
 787   1         IT01CF = IT01CF & 0xF0; // Clear bit de configuration INT0
 788   1                                 //    +----- Etat Haut
 789   1                                 //    |+++-- INT0 sur bit 6 du port 0
 790   1                                 //    ||||
 791   1         IT01CF = IT01CF | 0x0E; //xxxx1110
 792   1         IE0 = 0; // Efface une interruption résiduelle
 793   1         PX0=1;      //Priority maximum!
 794   1                     
 795   1      } // Init_Int0 ----------------------------------------------------------------
 796          
 797          
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 14  

 798          /*---------------------------------------------------------------------------*-
 799          Init_int1()
 800          -----------------------------------------------------------------------------
 801          Descriptif: Initialisation de l'interruption INT1 sur bit 7 port 0 actif sur 
 802          transition montante.
 803          Entrée : --
 804          Sortie : --
 805          -*---------------------------------------------------------------------------*/
 806          void Init_Int1()
 807          {
 808   1      
 809   1         //-- Démarrage de la configuration pour INT1 --
 810   1         EX1 = 0;             // Inhibe l'interruption INT1
 811   1         //-- Matériel --
 812   1         IT1 = 1;                // Interruption actif sur transition.
 813   1         IT01CF = IT01CF & 0x0F; // Clear bit de configuration INT1
 814   1                                 //    +----- Etat haut
 815   1                                 //    |+++-- INT1 sur bit 7 du port 0
 816   1                                 //    ||||
 817   1         IT01CF = IT01CF | 0xF0; //   1111xxxx
 818   1         IE1 = 0; // Efface une interruption résiduelle
 819   1         EX1 = 1; //Autorise l'interruption INT1
 820   1                     
 821   1      } // Init_Int1 ----------------------------------------------------------------
 822          
 823          
 824          
 825          
 826          /*---------------------------------------------------------------------------*-
 827          SPI0interrupt ()
 828          -----------------------------------------------------------------------------
 829          Descriptif: à chaque fin d'envoi de données, cette fonction est appellée.
 830          
 831          Entrée : --
 832          Sortie : --
 833          -*---------------------------------------------------------------------------*/
 834          void Interrupt_Spi() interrupt INTERRUPT_SPI0
 835          {
 836   1         //========Variables locales=========
 837   1         //démarre de 1 puisque la première données est déjà envoyée
 838   1         static unsigned char cpt = 1; 
 839   1         //==================================
 840   1         if (SPIF)   //Si les données ont été envoyées
 841   1         {     
 842   2            if (cpt<8)  //Si les données n'ont pas toutes été envoyées,
 843   2            {
 844   3               // Write to spi la prochaine ligne du tableau à l'étage correspondant
 845   3               SPI0DAT = ptrledcube[cpt][layer_cube]; 
 846   3               cpt++;   //Incrémentation du compteur
 847   3            }
 848   2            else
 849   2            {
 850   3        
 851   3               cpt = 1; //RA1 du compteur 
 852   3                  
 853   3               //latch des données dans les micrel pendant un temps supérieur à 100[ns]
 854   3               Micrel_strb = 1;  
 855   3               Micrel_strb = 1;  
 856   3               Micrel_strb = 0;
 857   3               //Si le cmp du PCA était activé avant la communication
 858   3               if(flag_pca_cmp_act)    
 859   3               {
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 15  

 860   4                  PCA0CPH0 = pwm_prechg;     //Préchargement du PWM
 861   4               }
 862   3               else
 863   3               {
 864   4                  //Désactivation du cmp du module 0 PCA0
 865   4                  PCA0CPM0 &= ~PCA0CPM0_ECOM_BIT;     
 866   4               }           
 867   3      
 868   3               //pin CEX0 (ici PWM commun à Micrel_out_en) connecté
 869   3               XBR1 |= CEX0_XBR_BIT;   
 870   3               PCA0CN |= PCA0CN_ACT_BIT;  //Activation du PWM
 871   3               memory_lock = 0;  //libération de la mémoire du cube
 872   3            }
 873   2         }
 874   1      
 875   1         WCOL = 0;
 876   1         MODF = 0;
 877   1         RXOVRN = 0;
 878   1         SPIF = 0;      //RAZ des Flag d'interruption
 879   1      } // SPI0interrupt ------------------------------------------------------------     
 880          
 881          
 882          /*---------------------------------------------------------------------------*-
 883             Interrupt_Int0()
 884            -----------------------------------------------------------------------------
 885             Descriptif: interruption int0 sur front montant pour la détection du clk 
 886             des étages (800 [Hz]).
 887          
 888          
 889             Entrée    : --
 890             Sortie    : --
 891          -*---------------------------------------------------------------------------*/
 892          void Interrupt_Int0() interrupt INTERRUPT_INT0
 893          {
 894   1         //========Variables locales=========
 895   1         static bit clk_sync = 0;
 896   1         static unsigned char clk_count = 0; //Pour le tableau
 897   1         unsigned char nop;
 898   1         //==================================
 899   1      
 900   1         //pin CEX0 (ici PWM commun à Micrel_out_en) déconnecté
 901   1         XBR1 &= ~CEX0_XBR_BIT;  
 902   1         Micrel_out_en = 1;      //Inhibition des sorties drivers au démarrage
 903   1         PCA0CN &= ~PCA0CN_ACT_BIT; //Arrêt du PWM
 904   1         PCA0L = 0x00;  //Reset du compteur interne au PWM
 905   1      
 906   1      
 907   1         if(!clk_sync)  //Si le clk n'est pas encore synchronisé avec l'étage,
 908   1         {
 909   2            for (nop = 0; nop<40 ;nop++)     //Attente d'environs 20us!
 910   2            {                    //(pour attente de stabilisation L0_detect)
 911   3            }
 912   2         }  //Attente!
 913   1            
 914   1      
 915   1       
 916   1         //Si l'étage 0 est actif et que le clk n'est pas encore synchro et 
 917   1         //que 8 clk au moins ont déjà été reçus
 918   1           
 919   1         if (L0_detect && (clk_count > 7) && (clk_sync == 0))   
 920   1         {    
 921   2            clk_sync = 1;     //le compteur est synchronisé avec le n° de l'étage actif
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 16  

 922   2            clk_count = 0;
 923   2         }
 924   1      
 925   1         if (clk_sync)     //Si le clk est synchronisé
 926   1         {
 927   2            if (clk_count>7)  //Si le clk est de nouveau celui de l'étage 0
 928   2            {
 929   3               clk_count = 0; //mise à 0 du compteur de clk
 930   3            }
 931   2            //la variable globale prends la valeur de l'étage en cours de sélection
 932   2            layer_cube = clk_count;     
 933   2      
 934   2            memory_lock = 1;   //Avertissement de mémoire cube bloquée pour affichage
 935   2            
 936   2            // envoi des données de l'étage en cours via spi aux drivers 
 937   2            SPI0DAT = ptrledcube[0][clk_count];  
 938   2         }
 939   1      
 940   1         clk_count++;   //A chaque coup de clk reçu, cette variables est incrémentée
 941   1      
 942   1      } // Interrupt_Int0 -----------------------------------------------------------
 943          
 944          
 945          
 946          /*---------------------------------------------------------------------------*-
 947             Interrupt_Int1()
 948            -----------------------------------------------------------------------------
 949             Descriptif: interruption int1 sur front montant averti en cas d'appui de
 950             bouton poussoir
 951          
 952          
 953             Entrée    : --
 954             Sortie    : --
 955          -*---------------------------------------------------------------------------*/
 956          void Interrupt_Int1() interrupt INTERRUPT_INT1
 957          {   
 958   1         if(flag_gestion_btn) //Si la gestion des boutons est activée,
 959   1         {
 960   2             if (!Sw_ok)      //Si un appui est constaté sur le bouton ok (priorité)
 961   2               btn_ok = 1;    //Passage du flag correspondant à 1.
 962   2             else if (!Sw_suiv)  //Sinon, si c'est le btn suivant
 963   2               btn_suiv = 1;  
 964   2             else             //Sinon btn précédent
 965   2               btn_prec = 1;  
 966   2         }  
 967   1      } // Interrupt_Int1 -----------------------------------------------------------
 968          
 969          
 970          /*---------------------------------------------------------------------------*-
 971             Interrupt_timer0()
 972            -----------------------------------------------------------------------------
 973             Descriptif: interruption du timer0 toutes les 10ms. 
 974             permet de gérer le temps d'affichage
 975          
 976             Entrée    : --
 977             Sortie    : --
 978          -*---------------------------------------------------------------------------*/
 979          void Interrupt_Timer0() interrupt INTERRUPT_TIMER0
 980          {  
 981   1         //--- Variables locales ----------------------------------------------------- 
 982   1         //--------------------------------------------------------------------------- 
 983   1       
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 17  

 984   1         TR0 = 0;                   //Stop le timer 
 985   1         TH0 = TIMER0_LOAD / 256;   //Recharge la valeur initiale 
 986   1         TL0 = TIMER0_LOAD % 256;   
 987   1         TR0 = 1;                   //Démarre le timer 
 988   1      
 989   1         //Incrémentation de la variable temporelle du programme (main).
 990   1         time_global+=10; 
 991   1         
 992   1      
 993   1      } // Interrupt_Timer0 ----------------------------------------------------------
 994                
 995          
 996          /*---------------------------------------------------------------------------*-
 997             Cube_car()
 998            -----------------------------------------------------------------------------
 999             Descriptif:  Tracer un caractère avec la Fonte 5 x 7 points (provenant de
1000             l'écran LCD couleur Chinois de mon 2ème trv. de semestre) tout en haut à
1001             gauche, sur la face choisie!
1002          
1003             Entrée    : Pointeur sur le tableau 2D (cube); 
1004                (unsigned char) face où la font sera appliquée ;(char) caractère
1005             Sortie    : --
1006          -*---------------------------------------------------------------------------*/
1007          void Cube_car(unsigned char ptr_newcube[][8],unsigned char face_nb ,char caract)
1008          {
1009   1         xdata unsigned char i,j;   // Compteurs
1010   1         xdata char pixelData[5];   // enregistre les données du caractere
1011   1         
1012   1      
1013   1      //Vérifie si le caractere est stocké dans le 1er tableau de caractères )
1014   1         if(caract < 'S')     
1015   1               memcpy(pixelData, FONT[caract - ' '], 5);
1016   1      //Sinon, regarde si le caractere est stocké dans le 2eme tableau de caractères 
1017   1         else if(caract <= '~')        
1018   1               memcpy(pixelData, FONT2[caract - 'S'], 5);
1019   1         else
1020   1               // Si caractere non trouvé alors considerer comme espace
1021   1               memcpy(pixelData, FONT[0], 5);   
1022   1               
1023   1         
1024   1         //Code pour afficher le texte sur la face avant du cube
1025   1         for(j=0;j<5;j++)
1026   1         {
1027   2            for(i=0;i<8;i++)  //répéter 8x         tout d'un coup
1028   2            {
1029   3               if (i<=j)
1030   3                  ptr_newcube [face_nb][i] |= (pixelData[j] & (0x80>>i))>>(j-i); 
1031   3               else  
1032   3                  ptr_newcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);        
1033   3         
1034   3            }  
1035   2         }
1036   1      } // Cube_car -----------------------------------------------------------------
1037          
1038          
1039          
1040          /*---------------------------------------------------------------------------*-
1041             rotat_h()
1042            -----------------------------------------------------------------------------
1043             Descriptif: représente le cube avec une rotation de l'image à 90° à droite 
1044             si sens = 1, ou à gauche si sens = 0.
1045          
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 18  

1046             Entrée    : ptr_ledcube pour la lecture de l'image source, ptr_newcube pour
1047             la mise en place de la nouvelle image tournée. (bit) sens (voir descriptif).
1048             Sortie    : --
1049          -*---------------------------------------------------------------------------*/
1050          void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], 
1051          bit sens)
1052          {
1053   1         //=========Déclarations locales============
1054   1         xdata unsigned char i,j,k;    
1055   1         //=========================================  
1056   1      
1057   1         //note: plus de code pour économiser en temps d'exécution!
1058   1               
1059   1         if(sens)    //Si sens pour rotation image à gauche
1060   1         {  
1061   2            for(i=0;i<8;i++)    //répéter 8x
1062   2            {
1063   3               for(j=0;j<8;j++)     //répéter 8x        
1064   3               {
1065   4                  for(k=0;k<8;k++)  //répéter 8x (bit par ligne)       
1066   4                  {
1067   5                     ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | 
1068   5                                             ((ptr_ledcube[k][i]&(1<<j))>>j);    
1069   5                  }
1070   4               }  
1071   3            }  
1072   2         }
1073   1         else     //Si rotation à droite
1074   1         {
1075   2            for(i=0;i<8;i++)     //répéter 8x   
1076   2            {
1077   3               for(j=0;j<8;j++)     //répéter 8x        
1078   3               {
1079   4                  for(k=0;k<8;k++)  //répéter 8x (bit par ligne)      
1080   4                  {
1081   5                     ptr_newcube [j] [i] =  (ptr_newcube [j][i]>>1) | 
1082   5                                                   ((ptr_ledcube[k][i]&(0x80>>j))<<j);     
1083   5                  }                                        
1084   4               }  
1085   3            }     
1086   2         }
1087   1      } // rotat_h ------------------------------------------------------------------
1088          
1089          
1090          /*---------------------------------------------------------------------------*-
1091             tabtoface()
1092            -----------------------------------------------------------------------------
1093             Descriptif: copie un tableau sur la face désirée
1094          
1095             Entrée    : (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
1096             Sortie    : --
1097          -*---------------------------------------------------------------------------*/
1098          void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],
1099          unsigned char face_nb)
1100          {
1101   1         //=========Déclarations locales============
1102   1         xdata unsigned char i;     
1103   1         //=========================================  
1104   1         
1105   1         for (i=0;i<8;i++)    
1106   1         {              
1107   2            ptr_newcube [face_nb][7-i] = ptr_tab [i];    
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 19  

1108   2         }    
1109   1      } // tabtoface ----------------------------------------------------------------
1110          
1111          
1112          
1113          /*---------------------------------------------------------------------------*-
1114             tabtolayer()
1115            -----------------------------------------------------------------------------
1116             Descriptif: copie un tableau sur l'étage désirée
1117          
1118             Entrée    : le pointeur du tableau source, le pointeur de l'image 3D,
1119             (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
1120             Sortie    : --
1121          -*---------------------------------------------------------------------------*/
1122          void tabtolayer(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],
1123          unsigned char etage_nb)
1124          {
1125   1         //=========Déclarations locales============
1126   1         xdata unsigned char i;     
1127   1         //=========================================  
1128   1         
1129   1         for (i=0;i<8;i++)    
1130   1         {              
1131   2            ptr_newcube [i][etage_nb] = ptr_tab [i];     
1132   2         }    
1133   1      } // tabtoface ----------------------------------------------------------------
1134          
1135             
1136          /*---------------------------------------------------------------------------*-
1137             anim_base_up()
1138            -----------------------------------------------------------------------------
1139             Descriptif: Un plateau monte de l'étage 0 à l'étage 7 en boucle. 
1140          
1141             Entrée    : pointeur sur le tableau 2D à modifier.
1142             Sortie    : --
1143          -*---------------------------------------------------------------------------*/
1144          void anim_base_up(unsigned char ptr_newcube[][8])
1145          {
1146   1         //=========Déclarations locales============
1147   1         xdata unsigned char i;
1148   1         static xdata unsigned char cpt = 0;    
1149   1         //=========================================  
1150   1      
1151   1         for (i=0;i<8;i++)
1152   1         { 
1153   2            //mise en place de valeur 0xFF dans l'étage en cours!
1154   2            ptr_newcube [i][cpt] = 0xFF;    
1155   2            ptr_newcube [i][(cpt-1)%8] = 0x00;  
1156   2            //mise en place de valeur 0x00 dans l'étage précédent!
1157   2         }    
1158   1      
1159   1         cpt = (cpt+1)%8; //pour repartir de l'étage 0 une fois le 7ème atteint.
1160   1      
1161   1      } // anim_base_up -------------------------------------------------------------
1162          
1163             
1164          /*---------------------------------------------------------------------------*-
1165             anim_base_up_dn()
1166            -----------------------------------------------------------------------------
1167             Descriptif: animation de l'étage 0 montant, puis descendant.
1168          
1169             Entrée    : pointeur sur le tableau 2D à modifier et 
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 20  

1170                         (bit) new pour indiquer si nouvelle animation
1171             Sortie    : --
1172          -*---------------------------------------------------------------------------*/
1173          void anim_base_up_dn(unsigned char ptr_newcube[][8], bit new)
1174          {
1175   1         //=========Déclarations locales============
1176   1         static xdata unsigned char cpt = 0;
1177   1         static bit sens = 1;    
1178   1         //=========================================  
1179   1      
1180   1         //sens à 1 pour monter, 0 pour descendre
1181   1      
1182   1         if (new)    //Si nouvelle anim,
1183   1         {
1184   2             cpt = 0;      //Redémarrage du cycle d'anim
1185   2             sens = 1;
1186   2         }
1187   1         else
1188   1         {
1189   2            Depl_hauteur(ptr_newcube, sens); //Déplacement en hauteur effectué!
1190   2         }
1191   1                
1192   1         if(cpt == 7)
1193   1            sens = 0;
1194   1         else if (cpt==0) 
1195   1            sens = 1;
1196   1         
1197   1         if (sens)
1198   1            cpt++;
1199   1         else
1200   1            cpt--;   
1201   1      } // anim_base_up_dn ----------------------------------------------------------
1202          
1203          
1204          /*---------------------------------------------------------------------------*-
1205             anim_base_l_r()
1206            -----------------------------------------------------------------------------
1207             Descriptif: animation de plaque défillante à droite, puis à gauche.
1208          
1209             Entrée    : --
1210             Sortie    : --
1211          -*---------------------------------------------------------------------------*/
1212          void anim_base_l_r(unsigned char ptr_newcube[][8], bit new)
1213          {
1214   1         //=========Déclarations locales============
1215   1         static xdata unsigned char cpt = 0;
1216   1         static bit sens = 1;    
1217   1         //=========================================  
1218   1         
1219   1      
1220   1         if (new)    //Si nouvelle anim,
1221   1         {
1222   2             cpt = 0;      //Redémarrage du cycle d'anim
1223   2             sens = 1;
1224   2         }
1225   1         else
1226   1         {
1227   2            Depl_largeur(ptr_newcube,sens);  //Déplacement de l'image en largeur
1228   2         }
1229   1      
1230   1         if(cpt == 7)   //Inversion du sens à chaque butée atteinte
1231   1         {
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 21  

1232   2            sens ^= 1;
1233   2            cpt++;
1234   2         }  
1235   1         cpt = (cpt+1)%8;  //cpt 0 à 7
1236   1         
1237   1      } // anim_base_l_r ------------------------------------------------------------
1238          
1239          
1240          /*---------------------------------------------------------------------------*-
1241             anim_pluie()
1242            -----------------------------------------------------------------------------
1243             Descriptif: trois animation de pluie différentes peuvent-être sélectionnées
1244             selon la valeur d'anim_nb(1,2 ou 3). 
1245          
1246             Entrée    : le pointeur du tableau 2D à modifier. 
1247                         (unsigned char) anim_nb (pouvant prendre de 1 à 3).
1248             Sortie    : --
1249          -*---------------------------------------------------------------------------*/
1250          void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb)
1251          {
1252   1         //=========Déclarations locales============
1253   1         xdata unsigned char i,j;
1254   1         static xdata unsigned char cpt = 0; 
1255   1         //=========================================  
1256   1      
1257   1                 
1258   1         switch(anim_nb)
1259   1         {
1260   2            case 1:
1261   2            {
1262   3               Depl_hauteur(ptr_newcube,0);  //Déplacement du cube vers le bas!
1263   3               
1264   3               for (j=0;j<8;j++)    //pour générer la pluie aléatoire sur le 1er étage
1265   3               { 
1266   4                  //mise en place de valeur dans le tableau! 
1267   4                  ptr_newcube [j][7] = rand();  
1268   4               }
1269   3            }  
1270   2            break;    
1271   2      
1272   2      
1273   2            case 2: //======================== pluie cube n°2 =======================               
1274   2          
1275   2               for (j=0;j<7;j++)    //répéter 7x  (de 6 à 0)
1276   2               { 
1277   3                  for (i=0;i<8;i++)          //répéter 8x 
1278   3                  { 
1279   4                     //Copie du tableau de l'étage supérieur vers l'étage inférieur!
1280   4                     ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                       
1281   4                  }
1282   3               }
1283   2      
1284   2               if((cpt%2)==0) //une fois sur deux la pluie sera regénérée
1285   2               {
1286   3                  for (j=0;j<8;j++) //pour générer la pluie aléatoire sur le 1er étage
1287   3                  { 
1288   4                     //mise en place de valeur aléatoires dans le tableau!
1289   4                     ptr_newcube [j][7] = rand();   
1290   4                  }
1291   3               }
1292   2               else     //L'autre fois sur deux, 
1293   2               {
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 22  

1294   3      
1295   3               }
1296   2               cpt++;
1297   2            break;
1298   2      
1299   2      
1300   2            case 3:
1301   2                  
1302   2            //============================= pluie cube n3 ===========================
1303   2             
1304   2               for (j=0;j<7;j++)    //répéter 7x  (de 6 à 0)
1305   2               { 
1306   3                  for (i=0;i<8;i++)          //répéter 8x 
1307   3                  { 
1308   4                     //Copie du tableau de l'étage supérieur vers l'étage inférieur!
1309   4                     ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                       
1310   4                  }
1311   3               }
1312   2         
1313   2               cpt++;
1314   2         
1315   2               if((cpt>=1)&&(cpt<=3))  //une fois sur huit nouvelle pluie sera générée
1316   2               {
1317   3               //répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
1318   3                  for (j=0;j<8;j++)    
1319   3                  { 
1320   4                     //mise en place de valeur aléatoire dans le tableau! 
1321   4                     ptr_newcube [j][7] = rand();  
1322   4                  }
1323   3               }
1324   2               else if (cpt >= 8)
1325   2               {
1326   3                  cpt = 0;    
1327   3               }
1328   2               else
1329   2               {
1330   3                  for (j=0;j<8;j++)    
1331   3                  { 
1332   4                     ptr_newcube [j][7] = 0x00; //premier étage éteint
1333   4                  }
1334   3               }
1335   2               break;   
1336   2         }
1337   1      } // anim_pluie ---------------------------------------------------------------
1338          
1339          
1340          /*---------------------------------------------------------------------------*-
1341             Copy_cube()
1342            -----------------------------------------------------------------------------
1343             Descriptif: copie un tableau source 2D dans un tableau dest 2D 
1344          
1345             Entrée    : pointeurs 2D: tab_src pour lecture des données, 
1346                         tab_dst pour écriture.
1347             Sortie    : --
1348          -*---------------------------------------------------------------------------*/
1349          void Copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
1350          {
1351   1         //=========Déclarations locales============
1352   1         xdata unsigned char i,j;
1353   1         //=========================================
1354   1      
1355   1         for(i=0;i<8;i++)        //64x
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 23  

1356   1         {
1357   2            for(j=0;j<8;j++)
1358   2            {
1359   3               tab_dst[j][i] = tab_src[j][i];   //copie des bytes          
1360   3            }  
1361   2         }  
1362   1      } // Copy_cube ----------------------------------------------------------------
1363          
1364          
1365          /*---------------------------------------------------------------------------*-
1366             Or_cube()
1367            -----------------------------------------------------------------------------
1368             Descriptif: n'allume que les points à 1 du tableau source dans celui 
1369             de destination.  (Donc effectue un OR logique).
1370          
1371             Entrée    : pointeurs 2D: tab_src pour lecture des données, 
1372                         tab_dst pour écriture.
1373             Sortie    : --
1374          -*---------------------------------------------------------------------------*/
1375          void Or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
1376          {
1377   1         //=========Déclarations locales============
1378   1         xdata unsigned char i,j;
1379   1         //=========================================
1380   1      
1381   1         for(i=0;i<8;i++)        //64x
1382   1         {
1383   2            for(j=0;j<8;j++)
1384   2            {
1385   3               tab_dst[j][i] |= tab_src[j][i];     //OR des bytes          
1386   3            }  
1387   2         }  
1388   1      } // Or_cube ------------------------------------------------------------------
1389          
1390          
1391          /*---------------------------------------------------------------------------*-
1392             Clear_cube()
1393            -----------------------------------------------------------------------------
1394             Descriptif: éteint un cube. (mise à 0 de toutes les variable du tableau 2D).
1395          
1396             Entrée    : Pointeur sur tableau 2D.
1397             Sortie    : --
1398          -*---------------------------------------------------------------------------*/
1399          void Clear_cube(unsigned char ptr_tab[][8])
1400          {
1401   1         //=========Déclarations locales============
1402   1         xdata unsigned char i,j;
1403   1         //=========================================
1404   1      
1405   1         for(i=0;i<8;i++)        //64x
1406   1         {
1407   2            for(j=0;j<8;j++)
1408   2            {
1409   3               ptr_tab[j][i] = 0x00;   //mise à 0 des bytes          
1410   3            }  
1411   2         }  
1412   1      } // Clear_cube ---------------------------------------------------------------
1413          
1414          
1415          
1416          /*---------------------------------------------------------------------------*-
1417             wr_coord_cube()
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 24  

1418            -----------------------------------------------------------------------------
1419             Descriptif: met dans l'état désiré le bit correspondant à la led choisie 
1420             dans un tableau "de cube". le système d'axe va de -4 à + 4, le 0 étant 
1421             ignoré.
1422          
1423             Entrée    : ptr_coord : pointeur sur la structure contenant les coordonés  .
1424                         (bit) state : état d'affectation led 
1425                         ptr_tab : pointeur tableau 2S sur l'image à lire.
1426             Sortie    : --
1427          -*---------------------------------------------------------------------------*/
1428          void Wr_coord_cube(coord *ptr_coord,bit state,unsigned char ptr_tab[][8])
1429          {
1430   1         xdata char x = ptr_coord->x;  //enregistrement structure dans buffer
1431   1         xdata char y = ptr_coord->y;
1432   1         xdata char z = ptr_coord->z;
1433   1      
1434   1      //Si le point n'est pas sur un axe (0) et qu'il est situé dans l'espace du cube
1435   1         if(x&&y&&z&&(x<5)&&(y<5)&&(z<5)&&(x>-5)&&(y>-5)&&(z>-5)) 
1436   1         {
1437   2            x = (x>0)? 4-x:3-x;
1438   2            y = (y>0)? y+3:y+4;
1439   2            z = (z>0)? 4-z:3-z;     
1440   2            if(state)
1441   2            {
1442   3               ptr_tab[z][y] |= (0x01<<x);
1443   3            }
1444   2            else
1445   2            {
1446   3               ptr_tab[z][y] &= (~(0x01<<x));
1447   3            }
1448   2         }
1449   1      } // Wr_coord_cube ------------------------------------------------------------
1450          
1451          
1452          
1453          /*---------------------------------------------------------------------------*-
1454             Rd_coord_cube()
1455            -----------------------------------------------------------------------------
1456             Descriptif: lis et retourne l'état de la led concernée dans l'espace 
1457             tri-dimensionnel.
1458          
1459             Entrée    : ptr_coord : pointeur sur la structure contenant les coordonés  .
1460                         ptr_tab : pointeur tableau 2S sur l'image à lire.
1461          
1462             Sortie    : bit à 1 si le bit (led) concerné est à 1.
1463          -*---------------------------------------------------------------------------*/
1464          bit Rd_coord_cube(coord *ptr_coord,unsigned char ptr_tab[][8])
1465          {
1466   1         xdata char x = ptr_coord->x;  //enregistrement structure dans buffer
1467   1         xdata char y = ptr_coord->y;
1468   1         xdata char z = ptr_coord->z;
1469   1      
1470   1      //Si le point n'est pas sur un axe (0) et qu'il est situé dans l'espace du cube  
1471   1         if(x&&y&&z&&(x<5)&&(y<5)&&(z<5)&&(x>-5)&&(y>-5)&&(z>-5)) 
1472   1         {
1473   2            x = (x>0)? 4-x:3-x;
1474   2            y = (y>0)? y+3:y+4;
1475   2            z = (z>0)? 4-z:3-z;     
1476   2      
1477   2            return (bit)(ptr_tab[z][y]&(0x01<<x));
1478   2         }
1479   1      } // Rd_coord_cube ------------------------------------------------------------
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 25  

1480          
1481              
1482              
1483          /*---------------------------------------------------------------------------*-
1484             luminosite()
1485            -----------------------------------------------------------------------------
1486             Descriptif: un paramètre de 0 à 100 est passé afin de définir la valeur du PWM
1487             100 = luminosité max, 0 = éteint! 
1488          
1489             Entrée    : (unsigned char)  luminosité du cube de 0 à 100
1490             Sortie    : --
1491          -*---------------------------------------------------------------------------*/
1492          void luminosite(unsigned char lum)
1493          {     
1494   1         pwm_prechg = ((unsigned int)lum*255/100); //conversion du % en 
1495   1                                                   //valeur de préchargement PWM
1496   1         if (lum == 100)   //Si la luminosité maximale est demandée,
1497   1         {  
1498   2            flag_pca_cmp_act = 0;   //Le comparateur du module 0 sera désactivé  
1499   2         }
1500   1         else
1501   1         {
1502   2            flag_pca_cmp_act = 1;   //Le comparateur du module 1 sera désactivé
1503   2         }
1504   1      } // luminosite ---------------------------------------------------------------
1505              
1506          
1507          /*---------------------------------------------------------------------------*-
1508          Init_Timer0()
1509          -----------------------------------------------------------------------------
1510          Descriptif: Initialisation du timer0 avec incrémentation toutes les 2 [us].
1511          Entrée : --
1512          Sortie : --
1513          -*---------------------------------------------------------------------------*/
1514          void Init_Timer0()
1515          {        
1516   1         
1517   1         TR0 = 0;    //Stop le timer
1518   1         ET0 = 0;    //Inhibe l'interruption du timer
1519   1         //--- Mode de fonctionnement du timer 0
1520   1      
1521   1         TMOD &= 0xF0;     //       reset initialisation timer 0
1522   1                           //     +----- Pas de gate externe
1523   1                           //     |+---- Fonction Temporisation
1524   1                           //     ||++-- Mode 1 16 bits
1525   1                           //     ||||
1526   1         TMOD |= 0x01;     // xxxx0010
1527   1      
1528   1         CKCON &= ~0x07;      // clear des bits pour config prescaler
1529   1      
1530   1                           //         +---- Prédiviseur activé                         
1531   1                           //         |++-- Système clock / 48 donc incréments 
1532   1                           //         |||                      toutes les 1 us.
1533   1         CKCON |= 0x02;    //    xxxx0010  
1534   1         
1535   1         TL0 = TIMER0_LOAD/256;  
1536   1         TH0 = TIMER0_LOAD%256;  //Charge la valeur initiale 
1537   1            
1538   1         
1539   1         TF0 = 0; //Clear une interruption résiduelle
1540   1         ET0 = 1; // Autorise l'interruption du timer 0
1541   1      
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 26  

1542   1      } // Init_Timer0 --------------------------------------------------------------
1543          
1544          
1545          /*---------------------------------------------------------------------------*-
1546             Tab_to_use()
1547            -----------------------------------------------------------------------------
1548             Descriptif: indique selon le flag d'utilisation du tableau en cours quel
1549                buffer utiliser en retournant le pointeur associé au buffer non-utilisé
1550                dans working_add.
1551          
1552             Entrée    : trois pointeurs de tableaux 2D.
1553             Sortie    : --
1554          -*---------------------------------------------------------------------------*/
1555          void Tab_to_use(unsigned char working_add[][8],unsigned char ptrbuff1[][8],
1556          unsigned char ptrbuff2[][8])
1557          {
1558   1         if (flag_buffcube1)     //Si le buff1 est utilisé
1559   1         {
1560   2            working_add = ptrbuff2; //le tableau de travail sera le buff2
1561   2         }        
1562   1         else           //Sinon,
1563   1         {
1564   2            working_add = ptrbuff1; //le tableau de travail sera le buff2
1565   2         }
1566   1      } // Tab_to_use --------------------------------------------------------------
1567          
1568          
1569          
1570          /*---------------------------------------------------------------------------*-
1571             Depl_profond()
1572            -----------------------------------------------------------------------------
1573             Descriptif: déplace le contenu du cube vers l'avant (sens = 0) 
1574             ou l'arrière (sens = 1), soit dans l'axe z
1575          
1576             Entrée    : Pointeur sur le tableau à modifier, (bit) pour le sens.
1577             Sortie    : --
1578          -*---------------------------------------------------------------------------*/
1579          void Depl_profond(unsigned char ptr_newcube[][8], bit sens)
1580          {
1581   1         //======Déclaration variables locales======
1582   1         xdata char i,j;
1583   1         //=========================================
1584   1      
1585   1         for (i=0;i<8;i++)             //répéter 8x (étage)
1586   1         { 
1587   2            if(sens)    //Si dépacement vers l'arrière
1588   2            {
1589   3               for (j=0;j<8;j++)       //répéter 8x (ligne)
1590   3               { 
1591   4                  if (j == 7)          //si la valeur de j est maximum au tableau,
1592   4                  {
1593   5                     //écriture de 0 en memoire pour éviter débordement
1594   5                     ptr_newcube [j] [i] = 0x00;   
1595   5                  }
1596   4                  else
1597   4                  {
1598   5                     ptr_newcube [j] [i] = ptr_newcube [j+1] [i]; //décalage des bytes!
1599   5                  }
1600   4               }
1601   3            }
1602   2            else        //Sinon,
1603   2            { 
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 27  

1604   3               for (j=7;j>=0;j--)      //répéter 8x (ligne)
1605   3               {        
1606   4                  if (j == 0)    //si la valeur de j est minimum au tableau,
1607   4                  {
1608   5                     ptr_newcube [j] [i] = 0x00;
1609   5                  }
1610   4                  else
1611   4                  {
1612   5                     ptr_newcube [j] [i] = ptr_newcube [j-1] [i]; //décalage des bytes!
1613   5                  }
1614   4               }
1615   3            }
1616   2         }
1617   1      } // Depl_profond --------------------------------------------------------------
1618          
1619          
1620          
1621          /*---------------------------------------------------------------------------*-
1622             Depl_largeur()
1623            -----------------------------------------------------------------------------
1624             Descriptif: déplace le contenu du cube vers la droite (sens = 1) 
1625             ou la gauche (sens = 0) , soit l'axe des x
1626          
1627             Entrée    : Pointeur sur le tableau 2D à modifier, (bit) pour le sens.
1628             Sortie    : --
1629          -*---------------------------------------------------------------------------*/
1630          void Depl_largeur(unsigned char ptr_newcube[][8], bit sens)
1631          {
1632   1         //======Déclaration variables locales======
1633   1         xdata unsigned char i,j;
1634   1         //=========================================
1635   1      
1636   1         for (i=0;i<8;i++)             //répéter 8x (étage)
1637   1         { 
1638   2            for (j=0;j<8;j++)       //répéter 8x (ligne)
1639   2            { 
1640   3               if (sens)            //si décalage à droite
1641   3               {
1642   4                  ptr_newcube [j] [i] = ptr_newcube [j] [i]>>1;   //décalage à droite
1643   4               }
1644   3               else
1645   3               {
1646   4                  ptr_newcube [j] [i] = ptr_newcube [j] [i]<<1;   //décalage à gauche
1647   4               }
1648   3            }
1649   2         }
1650   1      } // Depl_largeur -------------------------------------------------------------
1651          
1652          
1653          /*---------------------------------------------------------------------------*-
1654             Depl_hauteur()
1655            -----------------------------------------------------------------------------
1656             Descriptif: déplace le contenu du cube vers le haut (sens = 1) 
1657             ou la base (sens = 0), soit l'axe y.
1658          
1659             Entrée    : Pointeur sur le tableau 2D à modifier, (bit) pour le sens.
1660             Sortie    : --
1661          -*---------------------------------------------------------------------------*/
1662          void Depl_hauteur(unsigned char ptr_newcube[][8], bit sens)
1663          {
1664   1         //======Déclaration variables locales======
1665   1         xdata char i,j;
C51 COMPILER V8.12   MAIN_CUBE_LEDS                                                        06/12/2012 19:56:15 PAGE 28  

1666   1         //=========================================
1667   1         if (!sens)           //Si décalage descente choisie
1668   1         {
1669   2            for (i=0;i<8;i++)          //répéter 8x (étage)
1670   2            { 
1671   3               for (j=0;j<8;j++)       //répéter 8x (ligne)
1672   3               {     
1673   4                  if (i == 7) // pour éviter de sortir de la zone de mémoire
1674   4                     ptr_newcube [j] [i] = 0x00;   
1675   4                  else
1676   4                     ptr_newcube [j] [i] = ptr_newcube [j] [i+1]; //Descente
1677   4               }
1678   3            }
1679   2         }
1680   1         else        //Si Montée choisie
1681   1         {
1682   2            for (i=7;i>=0;i--)            //répéter 8x (étage)
1683   2            { 
1684   3               for (j=0;j<8;j++)       //répéter 8x (ligne)
1685   3               {     
1686   4                  if (i == 0) // pour éviter de sortir de la zone de mémoire
1687   4                     ptr_newcube [j] [i] = 0x00;   
1688   4                  else
1689   4                     ptr_newcube [j] [i] = ptr_newcube [j] [i-1]; //Montée
1690   4               }
1691   3            }
1692   2         }
1693   1      } // Depl_hauteur -------------------------------------------------------------


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7203    ----
   CONSTANT SIZE    =    574    ----
   XDATA SIZE       =     13     240
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2      85
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     10      12
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
