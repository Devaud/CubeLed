C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 1   


C51 COMPILER V8.12, COMPILATION OF MODULE F32X_USB_STANDARD_REQUESTS
OBJECT MODULE PLACED IN F32x_USB_Standard_Requests.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE F32x_USB_Standard_Requests.c OPTIMIZE(3,SPEED) BROWSE INCDIR(.\Header;.\Lib
                    -) DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          //-----------------------------------------------------------------------------
   2          // F32x_USB_Standard_Requests.c
   3          //-----------------------------------------------------------------------------
   4          // Copyright 2005 Silicon Laboratories, Inc.
   5          // http://www.silabs.com
   6          // FID:            32X000022
   7          // Target:         C8051F32x
   8          // Tool chain:     Keil C51 7.50 / Keil EVAL C51
   9          // Release 1.3
  10          // Adaptation pour modèle usbhid du cfpt : Neuhaus Jacques ( 30 juin 2010)
  11          //----------------------------------------------------------------------------
  12          
  13          #include <c8051f320.h>
  14          #include "GlobalDef.h"
  15          #include "GlobalDef_usbhid.h"
  16          #include "F32x_USB_Register.h"
  17          #include "F32x_USB_Descriptor.h"
  18          
  19          //-----------------------------------------------------------------------------
  20          // Externs
  21          //-----------------------------------------------------------------------------
  22          
  23          // These are created in USB_DESCRIPTOR.h
  24          extern device_descriptor DeviceDesc;            
  25          extern configuration_descriptor ConfigDesc;
  26          extern interface_descriptor HidDesc;         
  27          extern hid_report_descriptor HidReportDesc;
  28          extern interface_descriptor InterfaceDesc;
  29          extern endpoint_descriptor Endpoint1Desc;
  30          extern endpoint_descriptor Endpoint2Desc;
  31          extern BYTE* StringDescTable[];
  32          
  33          extern setup_buffer Setup;             // Buffer for current device request
  34          extern unsigned int DataSize;
  35          extern unsigned int DataSent;
  36          extern BYTE* DataPtr;
  37          
  38          extern BYTE Ep_Status[];               // Contains status bytes for EP 0-2
  39          extern BYTE USB_State;                 // Determines current usb device state
  40          
  41          //-----------------------------------------------------------------------------
  42          // Global Variables
  43          //-----------------------------------------------------------------------------
  44          
  45          // These are response packets used for communication with host
  46          code BYTE ONES_PACKET[2] = {0x01, 0x00};        
  47          code BYTE ZERO_PACKET[2] = {0x00, 0x00};        
  48          
  49          //-----------------------------------------------------------------------------
  50          // Support Subroutines
  51          //-----------------------------------------------------------------------------
  52          
  53          //-----------------------------------------------------------------------------
  54          // Get_Status
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 2   

  55          //-----------------------------------------------------------------------------
  56          //
  57          // Return Value : None
  58          // Parameters   : None
  59          //
  60          // This routine returns a two byte status packet to the host
  61          //
  62          //-----------------------------------------------------------------------------
  63          
  64          void Get_Status(void)                  
  65          {                                      
  66   1      
  67   1         if (Setup.wValue.c[MSB] || Setup.wValue.c[LSB] ||
  68   1                                                      
  69   1         // If non-zero return length or data length not  equal to 2 then send a stall
  70   1         // indicating invalid request
  71   1         Setup.wLength.c[MSB]    || (Setup.wLength.c[LSB] != 2))                                               
  72   1         {                                            
  73   2            Force_Stall();
  74   2         }
  75   1      
  76   1         // Determine if recipient was device, interface, or EP
  77   1         switch(Setup.bmRequestType)                  
  78   1         {
  79   2            // If recipient was device
  80   2            case OUT_DEVICE:                          
  81   2               if (Setup.wIndex.c[MSB] || Setup.wIndex.c[LSB])
  82   2               {
  83   3                // Send stall if request is invalid
  84   3                  Force_Stall();             
  85   3               }
  86   2               else
  87   2               {
  88   3                // Otherwise send 0x00, indicating bus power and no
  89   3               // remote wake-up supported
  90   3                  DataPtr = (BYTE*)&ZERO_PACKET;      
  91   3                  DataSize = 2;                       
  92   3               }
  93   2               break;
  94   2      
  95   2            // See if recipient was interface
  96   2            case OUT_INTERFACE:                       
  97   2              // Only valid if device is configured and non-zero index
  98   2               if ((USB_State != DEV_CONFIGURED) ||
  99   2                    Setup.wIndex.c[MSB] || Setup.wIndex.c[LSB])                                                
 100   2               {
 101   3                // Otherwise send stall to host
 102   3                  Force_Stall();                      
 103   3               }
 104   2               else
 105   2               {
 106   3                // Status packet always returns 0x00
 107   3                  DataPtr = (BYTE*)&ZERO_PACKET;      
 108   3                  DataSize = 2;
 109   3               }
 110   2               break;
 111   2      
 112   2            // See if recipient was an endpoint
 113   2            case OUT_ENDPOINT:                        
 114   2              // Make sure device is configured and index msb = 0x00
 115   2               if ((USB_State != DEV_CONFIGURED) || Setup.wIndex.c[MSB])                   
 116   2               {                                     
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 3   

 117   3                  Force_Stall();              // otherwise return stall to host
 118   3               }
 119   2               else
 120   2               {
 121   3                  // Handle case if request is directed to EP 1
 122   3                  if (Setup.wIndex.c[LSB] == IN_EP1)  
 123   3                  {
 124   4                     if (Ep_Status[1] == EP_HALT)
 125   4                     {                                
 126   5                     // If endpoint is halted, return 0x01,0x00
 127   5                        DataPtr = (BYTE*)&ONES_PACKET;
 128   5                        DataSize = 2;
 129   5                     }
 130   4                     else
 131   4                     {
 132   5                     // Otherwise return 0x00,0x00 to indicate endpoint active
 133   5                        DataPtr = (BYTE*)&ZERO_PACKET;
 134   5                        DataSize = 2;
 135   5                     }
 136   4                  }
 137   3                  else
 138   3                  {
 139   4                  // If request is directed to endpoint 2, send either
 140   4                  // 0x01,0x00 if endpoint halted or 0x00,0x00 if endpoint is active
 141   4                     if (Setup.wIndex.c[LSB] == OUT_EP2)
 142   4                                                      
 143   4                     {                                
 144   5                        if (Ep_Status[2] == EP_HALT)
 145   5                        {
 146   6                           DataPtr = (BYTE*)&ONES_PACKET;
 147   6                           DataSize = 2;
 148   6                        }
 149   5                        else
 150   5                        {
 151   6                           DataPtr = (BYTE*)&ZERO_PACKET;
 152   6                           DataSize = 2;
 153   6                        }
 154   5                     }
 155   4                     else
 156   4                     {
 157   5                        Force_Stall();       // Send stall if unexpected data
 158   5                     }
 159   4                  }
 160   3               }
 161   2               break;
 162   2      
 163   2            default:
 164   2               Force_Stall();
 165   2               break;
 166   2         }
 167   1         if (Ep_Status[0] != EP_STALL)
 168   1         {
 169   2            // Set serviced Setup Packet, Endpoint 0 intransmit mode, 
 170   2           // and reset DataSent counter
 171   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);        
 172   2            Ep_Status[0] = EP_TX;                     
 173   2            DataSent = 0;
 174   2         }
 175   1      }
 176          
 177          //-----------------------------------------------------------------------------
 178          // Clear_Feature
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 4   

 179          //-----------------------------------------------------------------------------
 180          //
 181          // Return Value : None
 182          // Parameters   : None
 183          //
 184          // This routine can clear Halt Endpoint features on endpoint 1 and 2.
 185          //
 186          //-----------------------------------------------------------------------------
 187          
 188          void Clear_Feature()                            
 189          {                                               
 190   1      
 191   1         if ((USB_State != DEV_CONFIGURED)          ||// Send procedural stall if device isn't configured
 192   1         (Setup.bmRequestType == IN_DEVICE)         ||// or request is made to host(remote wakeup not supported)
 193   1         (Setup.bmRequestType == IN_INTERFACE)      ||// or request is made to interface
 194   1         Setup.wValue.c[MSB]  || Setup.wIndex.c[MSB]||// or msbs of value or index set to non-zero value
 195   1         Setup.wLength.c[MSB] || Setup.wLength.c[LSB])// or data length set to non-zero.
 196   1         {
 197   2            Force_Stall();
 198   2         }
 199   1      
 200   1         else
 201   1         {
 202   2            if ((Setup.bmRequestType == IN_ENDPOINT)&&// Verify that packet was directed at an endpoint
 203   2            (Setup.wValue.c[LSB] == ENDPOINT_HALT)  &&// the feature selected was HALT_ENDPOINT
 204   2            ((Setup.wIndex.c[LSB] == IN_EP1) ||       // and that the request was directed at EP 1 in
 205   2            (Setup.wIndex.c[LSB] == OUT_EP2)))        // or EP 2 out
 206   2            {
 207   3               if (Setup.wIndex.c[LSB] == IN_EP1)
 208   3               {
 209   4                  POLL_WRITE_BYTE (INDEX, 1);         // Clear feature endpoint 1 halt
 210   4                  POLL_WRITE_BYTE (EINCSR1, rbInCLRDT);
 211   4                  Ep_Status[1] = EP_IDLE;             // Set endpoint 1 status back to idle
 212   4               }
 213   3               else
 214   3               {
 215   4                  POLL_WRITE_BYTE (INDEX, 2);         // Clear feature endpoint 2 halt
 216   4                  POLL_WRITE_BYTE (EOUTCSR1, rbOutCLRDT);
 217   4                  Ep_Status[2] = EP_IDLE;             // Set endpoint 2 status back to idle
 218   4               }
 219   3            }
 220   2            else
 221   2            {
 222   3               Force_Stall();                         // Send procedural stall
 223   3            }
 224   2         }
 225   1         POLL_WRITE_BYTE(INDEX, 0);                   // Reset Index to 0
 226   1         if (Ep_Status[0] != EP_STALL)
 227   1         {
 228   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);
 229   2                                                      // Set Serviced Out packet ready and data end to
 230   2                                                      // indicate transaction is over
 231   2         }
 232   1      }
 233          
 234          //-----------------------------------------------------------------------------
 235          // Set_Feature
 236          //-----------------------------------------------------------------------------
 237          //
 238          // Return Value : None
 239          // Parameters   : None
 240          //
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 5   

 241          // This routine will set the EP Halt feature for endpoints 1 and 2
 242          //
 243          //-----------------------------------------------------------------------------
 244          
 245          void Set_Feature(void)                          
 246          {                                             
 247   1      
 248   1         if ((USB_State != DEV_CONFIGURED)          ||// Make sure device is configured, setup data
 249   1         (Setup.bmRequestType == IN_DEVICE)         ||// is all valid and that request is directed at
 250   1         (Setup.bmRequestType == IN_INTERFACE)      ||// an endpoint
 251   1         Setup.wValue.c[MSB]  || Setup.wIndex.c[MSB]||
 252   1         Setup.wLength.c[MSB] || Setup.wLength.c[LSB])
 253   1         {
 254   2            Force_Stall();                            // Otherwise send stall to host
 255   2         }
 256   1      
 257   1         else
 258   1         {
 259   2            if ((Setup.bmRequestType == IN_ENDPOINT)&&// Make sure endpoint exists and that halt
 260   2            (Setup.wValue.c[LSB] == ENDPOINT_HALT)  &&// endpoint feature is selected
 261   2            ((Setup.wIndex.c[LSB] == IN_EP1)        ||
 262   2            (Setup.wIndex.c[LSB] == OUT_EP2)))
 263   2            {
 264   3               if (Setup.wIndex.c[LSB] == IN_EP1)
 265   3               {
 266   4                  POLL_WRITE_BYTE (INDEX, 1);         // Set feature endpoint 1 halt
 267   4                  POLL_WRITE_BYTE (EINCSR1, rbInSDSTL);
 268   4                  Ep_Status[1] = EP_HALT;
 269   4               }
 270   3               else
 271   3               {
 272   4                  POLL_WRITE_BYTE (INDEX, 2);         // Set feature Ep2 halt
 273   4                  POLL_WRITE_BYTE (EOUTCSR1, rbOutSDSTL);
 274   4                  Ep_Status[2] = EP_HALT;
 275   4               }
 276   3            }
 277   2            else
 278   2            {
 279   3               Force_Stall();                         // Send procedural stall
 280   3            }
 281   2         }
 282   1         POLL_WRITE_BYTE(INDEX, 0);
 283   1         if (Ep_Status[0] != EP_STALL)
 284   1         {
 285   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);
 286   2                                                      // Indicate setup packet has been serviced
 287   2         }
 288   1      }
 289          
 290          //-----------------------------------------------------------------------------
 291          // Set_Address
 292          //-----------------------------------------------------------------------------
 293          //
 294          // Return Value : None
 295          // Parameters   : None
 296          //
 297          // Set new function address
 298          //
 299          //-----------------------------------------------------------------------------
 300          
 301          void Set_Address(void)                          
 302          {
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 6   

 303   1         if ((Setup.bmRequestType != IN_DEVICE)     ||// Request must be directed to device
 304   1         Setup.wIndex.c[MSB]  || Setup.wIndex.c[LSB]||// with index and length set to zero.
 305   1         Setup.wLength.c[MSB] || Setup.wLength.c[LSB]||
 306   1         Setup.wValue.c[MSB]  || (Setup.wValue.c[LSB] & 0x80))
 307   1         {
 308   2           Force_Stall();                             // Send stall if setup data invalid
 309   2         }
 310   1      
 311   1         Ep_Status[0] = EP_ADDRESS;                   // Set endpoint zero to update address next status phase
 312   1         if (Setup.wValue.c[LSB] != 0)
 313   1         {
 314   2            USB_State = DEV_ADDRESS;                  // Indicate that device state is now address
 315   2         }
 316   1         else
 317   1         {
 318   2            USB_State = DEV_DEFAULT;                  // If new address was 0x00, return device to default
 319   2         }                                            // state
 320   1         if (Ep_Status[0] != EP_STALL)
 321   1         {
 322   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);
 323   2                                                      // Indicate setup packet has been serviced
 324   2         }
 325   1      }
 326          
 327          //-----------------------------------------------------------------------------
 328          // Get_Descriptor
 329          //-----------------------------------------------------------------------------
 330          //
 331          // Return Value : None
 332          // Parameters   : None
 333          //
 334          // This routine sets the data pointer and size to correct 
 335          // descriptor and sets the endpoint status to transmit
 336          //
 337          //-----------------------------------------------------------------------------
 338          
 339          void Get_Descriptor(void)                       
 340          {                                              
 341   1      
 342   1         switch(Setup.wValue.c[MSB])                  // Determine which type of descriptor
 343   1         {                                            // was requested, and set data ptr and
 344   2            case DSC_DEVICE:                          // size accordingly
 345   2               DataPtr = (BYTE*) &DeviceDesc;
 346   2               DataSize = DeviceDesc.bLength;
 347   2               break;
 348   2      
 349   2            case DSC_CONFIG:
 350   2               DataPtr = (BYTE*) &ConfigDesc;
 351   2                                                      // Compiler Specific - The next statement reverses the
 352   2                                                      // bytes in the configuration descriptor for the compiler
 353   2               DataSize = ConfigDesc.wTotalLength.c[MSB] + 256*ConfigDesc.wTotalLength.c[LSB];
 354   2               break;
 355   2      
 356   2            case DSC_STRING:
 357   2               DataPtr = StringDescTable[Setup.wValue.c[LSB]];
 358   2                                                      // Can have a maximum of 255 strings
 359   2               DataSize = *DataPtr;
 360   2               break;
 361   2      
 362   2                                          // <-- Add HID class and HID report desc support
 363   2            case DSC_HID: // HID Specific (HID class descriptor)
 364   2               DataPtr = (BYTE*)&HidDesc;
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 7   

 365   2               DataSize = HidDesc.bLength;
 366   2               break;
 367   2      
 368   2            case DSC_HID_REPORT: // HID Specific (HID report descriptor)
 369   2               DataPtr = (BYTE*)&HidReportDesc;
 370   2               DataSize = HID_REPORT_DESCRIPTOR_SIZE;
 371   2               break;
 372   2      
 373   2      /*
 374   2            case DSC_INTERFACE:
 375   2               DataPtr = (BYTE*) &InterfaceDesc;
 376   2               DataSize = InterfaceDesc.bLength;
 377   2               break;
 378   2      
 379   2            case DSC_ENDPOINT:
 380   2               if ((Setup.wValue.c[LSB] == IN_EP1) ||
 381   2               (Setup.wValue.c[LSB] == OUT_EP2))
 382   2               {
 383   2                  if (Setup.wValue.c[LSB] == IN_EP1)
 384   2                  {
 385   2                     DataPtr = (BYTE*) &Endpoint1Desc;
 386   2                     DataSize = Endpoint1Desc.bLength;
 387   2                  }
 388   2                  else
 389   2                  {
 390   2                     DataPtr = (BYTE*) &Endpoint2Desc;
 391   2                     DataSize = Endpoint2Desc.bLength;
 392   2                  }
 393   2               }
 394   2               else
 395   2               {
 396   2                  Force_Stall();
 397   2               }
 398   2               break;
 399   2      */
 400   2            default:
 401   2               Force_Stall();                         // Send Stall if unsupported request
 402   2               break;
 403   2         }
 404   1      
 405   1         if (Setup.wValue.c[MSB] == DSC_DEVICE ||     // Verify that the requested descriptor is
 406   1         Setup.wValue.c[MSB] == DSC_CONFIG     ||     // valid
 407   1         Setup.wValue.c[MSB] == DSC_STRING     ||
 408   1         Setup.wValue.c[MSB] == DSC_INTERFACE  ||
 409   1         Setup.wValue.c[MSB] == DSC_ENDPOINT)
 410   1         {
 411   2            if ((Setup.wLength.c[LSB] < DataSize) &&
 412   2            (Setup.wLength.c[MSB] == 0))
 413   2            {
 414   3               DataSize = Setup.wLength.i;       // Send only requested amount of data
 415   3            }
 416   2         }
 417   1         if (Ep_Status[0] != EP_STALL)                // Make sure endpoint not in stall mode
 418   1         {
 419   2           POLL_WRITE_BYTE(E0CSR, rbSOPRDY);          // Service Setup Packet
 420   2           Ep_Status[0] = EP_TX;                      // Put endpoint in transmit mode
 421   2           DataSent = 0;                              // Reset Data Sent counter
 422   2         }
 423   1      }
 424          
 425          //-----------------------------------------------------------------------------
 426          // Get_Configuration
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 8   

 427          //-----------------------------------------------------------------------------
 428          //
 429          // Return Value : None
 430          // Parameters   : None
 431          //
 432          // This routine returns current configuration value
 433          //
 434          //-----------------------------------------------------------------------------
 435          
 436          void Get_Configuration(void)                   
 437          {
 438   1         if ((Setup.bmRequestType != OUT_DEVICE)    ||// This request must be directed to the device
 439   1         Setup.wValue.c[MSB]  || Setup.wValue.c[LSB]||// with value word set to zero
 440   1         Setup.wIndex.c[MSB]  || Setup.wIndex.c[LSB]||// and index set to zero
 441   1         Setup.wLength.c[MSB] || (Setup.wLength.c[LSB] != 1))// and setup length set to one
 442   1         {
 443   2            Force_Stall();                            // Otherwise send a stall to host
 444   2         }
 445   1      
 446   1         else
 447   1         {
 448   2            if (USB_State == DEV_CONFIGURED)          // If the device is configured, then return value 0x01
 449   2            {                                         // since this software only supports one configuration
 450   3               DataPtr = (BYTE*)&ONES_PACKET;
 451   3               DataSize = 1;
 452   3            }
 453   2            if (USB_State == DEV_ADDRESS)             // If the device is in address state, it is not
 454   2            {                                         // configured, so return 0x00
 455   3               DataPtr = (BYTE*)&ZERO_PACKET;
 456   3               DataSize = 1;
 457   3            }
 458   2         }
 459   1         if (Ep_Status[0] != EP_STALL)
 460   1         {
 461   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);         // Set Serviced Out Packet bit
 462   2            Ep_Status[0] = EP_TX;                     // Put endpoint into transmit mode
 463   2            DataSent = 0;                             // Reset Data Sent counter to zero
 464   2         }
 465   1      }
 466          
 467          //-----------------------------------------------------------------------------
 468          // Set_Configuration
 469          //-----------------------------------------------------------------------------
 470          //
 471          // Return Value : None
 472          // Parameters   : None
 473          //
 474          // This routine allows host to change current device configuration value
 475          //
 476          //-----------------------------------------------------------------------------
 477          
 478          void Set_Configuration(void)                   
 479          {                                               
 480   1      
 481   1         if ((USB_State == DEV_DEFAULT)             ||// Device must be addressed before configured
 482   1         (Setup.bmRequestType != IN_DEVICE)         ||// and request recipient must be the device
 483   1         Setup.wIndex.c[MSB]  || Setup.wIndex.c[LSB]||// the index and length words must be zero
 484   1         Setup.wLength.c[MSB] || Setup.wLength.c[LSB] ||
 485   1         Setup.wValue.c[MSB]  || (Setup.wValue.c[LSB] > 1))// This software only supports config = 0,1
 486   1         {
 487   2            Force_Stall();                            // Send stall if setup data is invalid
 488   2         }
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 9   

 489   1      
 490   1         else
 491   1         {
 492   2            if (Setup.wValue.c[LSB] > 0)              // Any positive configuration request
 493   2            {                                         // results in configuration being set to 1
 494   3               USB_State = DEV_CONFIGURED;
 495   3               Ep_Status[1] = EP_IDLE;                // Set endpoint status to idle (enabled)
 496   3               Ep_Status[2] = EP_IDLE;
 497   3               POLL_WRITE_BYTE(INDEX, 1);             // Change index to endpoint 1
 498   3               POLL_WRITE_BYTE(EINCSR2, rbInDIRSEL);  // Set DIRSEL to indicate endpoint 1 is IN
 499   3               Handle_In1();                          // Put first data packet on fifo
 500   3               POLL_WRITE_BYTE(INDEX, 0);             // Set index back to endpoint 0
 501   3            }
 502   2            else
 503   2            {
 504   3               USB_State = DEV_ADDRESS;               // Unconfigures device by setting state to
 505   3               Ep_Status[1] = EP_HALT;                // address, and changing endpoint 1 and 2
 506   3               Ep_Status[2] = EP_HALT;                // status to halt
 507   3            }
 508   2         }
 509   1         if (Ep_Status[0] != EP_STALL)
 510   1         {
 511   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);
 512   2                                                      // Indicate setup packet has been serviced
 513   2         }
 514   1      }
 515          
 516          //-----------------------------------------------------------------------------
 517          // Get_Interface
 518          //-----------------------------------------------------------------------------
 519          //
 520          // Return Value : None
 521          // Parameters   : None
 522          //
 523          // This routine returns 0x00, since only one interface is supported by 
 524          // this firmware
 525          //
 526          //-----------------------------------------------------------------------------
 527          
 528          void Get_Interface(void)                        
 529          {                                              
 530   1      
 531   1         if ((USB_State != DEV_CONFIGURED)      ||    // If device is not configured
 532   1         (Setup.bmRequestType != OUT_INTERFACE) ||    // or recipient is not an interface
 533   1         Setup.wValue.c[MSB]  ||Setup.wValue.c[LSB] ||// or non-zero value or index fields
 534   1         Setup.wIndex.c[MSB]  ||Setup.wIndex.c[LSB] ||// or data length not equal to one
 535   1         Setup.wLength.c[MSB] ||(Setup.wLength.c[LSB] != 1))
 536   1         {
 537   2            Force_Stall();                            // Then return stall due to invalid request
 538   2         }
 539   1      
 540   1         else
 541   1         {
 542   2            DataPtr = (BYTE*)&ZERO_PACKET;            // Otherwise, return 0x00 to host
 543   2            DataSize = 1;
 544   2         }
 545   1         if (Ep_Status[0] != EP_STALL)
 546   1         {
 547   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);         // Set Serviced Setup packet, put endpoint in transmit
 548   2            Ep_Status[0] = EP_TX;                     // mode and reset Data sent counter
 549   2            DataSent = 0;
 550   2         }
C51 COMPILER V8.12   F32X_USB_STANDARD_REQUESTS                                            06/12/2012 19:56:17 PAGE 10  

 551   1      }
 552          
 553          //-----------------------------------------------------------------------------
 554          // Set_Interface
 555          //-----------------------------------------------------------------------------
 556          //
 557          // Return Value : None
 558          // Parameters   : None
 559          //
 560          // This routine allows host to change current device configuration value
 561          //
 562          //-----------------------------------------------------------------------------
 563          
 564          void Set_Interface(void)
 565          {
 566   1         // Make sure request is directed at interface and all other packet values 
 567   1         // are set to zero
 568   1      
 569   1         if ((Setup.bmRequestType != IN_INTERFACE)  ||
 570   1         Setup.wLength.c[MSB] ||Setup.wLength.c[LSB]|| 
 571   1         Setup.wValue.c[MSB]  ||Setup.wValue.c[LSB] ||
 572   1         Setup.wIndex.c[MSB]  ||Setup.wIndex.c[LSB])
 573   1         {
 574   2            // Otherwise send a stall to host
 575   2            Force_Stall();                            
 576   2         }
 577   1         if (Ep_Status[0] != EP_STALL)
 578   1         {
 579   2            // Indicate setup packet has been serviced
 580   2            POLL_WRITE_BYTE(E0CSR, rbSOPRDY);                                             
 581   2         }
 582   1      }
 583          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1185    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
