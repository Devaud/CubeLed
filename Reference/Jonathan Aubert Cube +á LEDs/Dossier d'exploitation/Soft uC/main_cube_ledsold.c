/*===========================================================================*=
   CFP - Technique - Bus USB version HID  
   Modèle usbhid : Neuhaus J. adaptation du firmware Silicon Laboratories, Inc.
                   Modèle version 1.1 du 21 juin 2010. 
  -----------------------------------------------------------------------------                 
   Auteur        : Neuhaus J.    
   Date création : 21 juin 2010
   Modifié le    : 21 juin 2010
   Version       : 1.0
  =============================================================================
   Descriptif: Application support/exemple. 
               L'application Windows associée est F320_usbdid_WinDemo.  
                 
               Le fonctionnement de l'application est: 
   
               Sur l'application windows F320_usbdid_WinDemo 2 boutons de 
               commande définissent l'état des leds du kit F320 de SiLabs.
               Un troisième bouton permet d'activer le mode clignotement qui
               agira en sus de l'état de commande des leds.
   
               Un packet de données composé de 64 bytes est générés quand le 
               switch 1 du Kit Silabs est activé. Les valeurs sont consécutives
               et de type modulo 256 à partir d'une première valeur aléatoire.
               
               Les données sont envoyées sur une transition du switch 2 du kit
               Au niveau de l'application Windows la réception de données
               inverse l'état du témoin et les données sont actualisées au 
               niveau de la grille d'affichage. La réception de données sans 
               changement de valeur n'aura pas d'incidence sur l'application 
               Windows.
               
               A noter que l'application Windows de test HIdTestAPI permet
               aussi de tester l'application du kit, mais les opérations
               devront être faite manuellement au niveau des fenêtres de buffer  
=*===========================================================================*/

//--- Includes ----------------------------------------------------------------
#include <c8051f320.h>
#include "F32x_USB_Primitives.h"
#include <stdlib.h>             	// accès au générateur de nombre aléatoire
#include "Delay.h"               // unité gestion temporisation
#include "FONT5x7.c"             // police de caractères 5*7
#include <string.h>

// ==== Fonctions prototypes ==================================================
void Port_Init(void);            // Configure ports
void SPIInit ();               	// init config SPI
void Init_Int0();                // init INT0
void cube_txt(unsigned char layer,side , char* str_ptr); //écriture de txt
void anim_pluie(unsigned char** ptr_newcube,  unsigned char anim_nb);
void anim_base_l_r(unsigned char** ptr_newcube);
void anim_base_up(unsigned char** ptr_newcube);
void anim_base_up_dn(unsigned char** ptr_newcube);
void anim_cligno(unsigned char** ptr_tab,unsigned char** ptr_newcube);
void rotat_h(unsigned char** ptr_ledcube,unsigned char** ptr_newcube, bit sens);
void tabtoface(unsigned char* ptr_tab,unsigned char** ptr_newcube,unsigned char face_nb);


  


// ==== Equivalences ==========================================================

// ==== Variables globales ====================================================
xdata unsigned char ledcube [8][8]; 	//tableau pour cube!
xdata unsigned char layer_cube = 0;
bit spi_rdy = 0;
bit memory_lock = 0;                   //indique si mémoire occupée

sbit Micrel_strb = P0^3;
sbit Micrel_out_en = P0^4;
sbit Clk_layer = P0^5;
sbit L0_detect = P0^6;

//--- Pour application démo ---------------------------------------------------
//sbit Sw1  = P2^0;                    
//sbit Sw2  = P2^1;                       
//sbit Led1 = P2^2;  
//sbit Led2 = P2^3;
//bit fClignote=0;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*                                  MAIN                                       */
/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void main(void)
{
   //--- Variables locales ----------------------------------------------------

   xdata unsigned char cube_buffer [8][8];	 	//variables de traitement avant affichage
   xdata unsigned char i = 0, j = 0, main_cpt = 0 ,line = 0xF00;

   xdata int d;
 //  bit Sw2_old; 
   //--------------------------------------------------------------------------

   PCA0MD &= ~0x40; // Disable Watchdog timer
   Sysclk_Init();   // Initialize oscillator inclus spécificité usb
                    // Clock système sera fixé à 24MHz
   Port_Init();     // Initialize crossbar and GPIO
   SPIInit ();     	// init config SPI
   Init_Int0();     // init INT0 
   Usb0_Init();     // Initialize USB0 (Doit être la dernière routine init car
                    // autorisation générale de interrupt fait à un moment opportun
                    // dans cette routine) 

  // Led1=0; Led2=0;
  // Sw2_old=Sw2;

   
   Micrel_out_en = 1;	//Inhibition des sorties drivers au démarrage
   Micrel_strb = 0;
   spi_rdy = 1;
        /*
                    anim1
   for (i = 0; i<8;i++)
    { 
      ledcube [0][i] = 0xFF;    //mise en place de valeur dans le tableau!
      ledcube [1][i] = 0x00;
      ledcube [2][i] = 0x00;
      ledcube [3][i] = 0x00;
      ledcube [4][i] = 0x00;
      ledcube [5][i] = 0x00;
      ledcube [6][i] = 0x00;
      ledcube [7][i] = 0x00;
   }    
               */


   for (i = 0; i<8;i++)    
    { 
      for (j = 0; j<8;j++)
      {
         ledcube [j][i] = 0x00;    //mise en place de valeur 0 dans le cube!
      }
   }    


       
   ledcube [0][0] = 0x01;    //mise en place de valeur dans le tableau!
   ledcube [1][0] = 0x02;
   ledcube [2][0] = 0x04;
   ledcube [3][0] = 0x08;
   ledcube [4][0] = 0x10;
   ledcube [5][0] = 0x20;
   ledcube [6][0] = 0x40;
   ledcube [7][0] = 0xFF;
                	/*
   ledcube [0][1] = 0x00;    //mise en place de valeur dans le tableau!
   ledcube [1][1] = 0x00;
   ledcube [2][1] = 0x00;
   ledcube [3][1] = 0x00;
   ledcube [4][1] = 0x00;
   ledcube [5][1] = 0x00;
   ledcube [6][1] = 0x00;
   ledcube [7][1] = 0x00;

   ledcube [0][6] = 0x00;    //mise en place de valeur dans le tableau!
   ledcube [1][6] = 0x00;
   ledcube [2][6] = 0x00;
   ledcube [3][6] = 0x00;
   ledcube [4][6] = 0x00;
   ledcube [5][6] = 0x00;
   ledcube [6][6] = 0x00;
   ledcube [7][6] = 0x00;
    */
   /*ledcube [0][0] = 0xFF;    //mise en place de valeur dans le tableau!
   ledcube [1][0] = 0xFF;
   ledcube [2][0] = 0xFF;
   ledcube [3][0] = 0xFF;
   ledcube [4][0] = 0xFF;
   ledcube [5][0] = 0xFF;
   ledcube [6][0] = 0xFF;
   ledcube [7][0] = 0xFF;              
   //SPI0DAT =  ledcube[0][etage_cube];   // écriture de l'étage 0
   
           */
    /*
    ledcube [0][0] = 0xFF;    //mise en place de valeur dans le tableau!
   ledcube [1][0] = 0xFF;
   ledcube [2][0] = 0xFF;
   ledcube [3][0] = 0xFF;
   ledcube [4][0] = 0xFF;
   ledcube [5][0] = 0xFF;
   ledcube [6][0] = 0xFF;
   ledcube [7][0] = 0xFF;      
      */
   EX0 = 1; //Autorise l'interruption INT0     
           
   while (1)
   {

      //	memcpy(Tab2, Tab1, sizeof Tab2);
    
     
     /* 
	   line = line>>1;

     if (!line)
     {
         line = 0x80;
     }

     for (i=0;i<8;i++)
     {
         ledcube[i][etage_cube] = line;
     }
           
      	  //==================diagonale cube =======================
	/*  for (i=0;i<8;i++)
	  { 
	
	
	     ledcube [main_cpt][i] ^= 0xFF;    //mise en place de valeur dans le tableau!
	     ledcube [(++main_cpt)%8][i] = 0x00;    //mise en place de valeur dans le tableau!
	
	  }    
	
	  Delay_1ms (500);                      // temporisation 3 seconde  
	       
	      
	               */  
				   /*   
    // if (spi_rdy)    //Si un étage n'est pas en cours d'affichage
    // {
///     SPI0DAT = ledcube[0][etage_cube];   // écriture de l'étage 0 
   //  spi_rdy = 0; 
   //  }   
     
  //   Delay_1ms (70);                      // temporisation 3 seconde                                                      
      //--- Application démo, Exemple réception de données
       */


      /*
      	ledcube [0][0] ^= 0xFF;    //mise en place de valeur dans le tableau!
         ledcube [1][0] ^= 0xFF;
         ledcube [2][0] ^= 0xFF;
         ledcube [3][0] ^= 0xFF;
         ledcube [4][0] ^= 0xFF;
         ledcube [5][0] ^= 0xFF;
         ledcube [6][0] ^= 0xFF;
         ledcube [7][0] ^= 0xFF;    */
         
          
     
    //  while(memory_lock); //Attendre libération de la mémoire avant de continuer




   


     // 0x00, 0x04, 0x02, 0x7F, 0x00
  //   	cube_txt(0,0 , "3");



      //i=(i+1)%8;
      
      
             /*ledcube [0][i] = ^0xFF;    //mise en place de valeur dans le tableau!
         ledcube [1][i] = 0x00;
         ledcube [2][i] = 0x00;
         ledcube [3][i] = 0x00;
         ledcube [4][i] = 0x00;
         ledcube [5][i] = 0x00;
         ledcube [6][i] = 0x00;
         ledcube [7][i] = 0x00;

                                     */       
	  //Si de nouvelles données ont été reçues
     /* if (fNewData)
	  {  
	    //Transfert les données reçues dans le buffer
        Read_receive_Packet(ReceiveDataBuffer, sizeof(ReceiveDataBuffer));
      
		//Traitement des données reçus
	    if (ReceiveDataBuffer[0] == 1) 
	      Led1 = 1;  
	    else 
	      Led1 = 0;
	    if (ReceiveDataBuffer[1] == 1)

        v          	      Led2 = 1;   
	    else 
	      Led2 = 0;
	
		fClignote=(ReceiveDataBuffer[63] > 0);
			  
	  	fNewData = 0; //Quittance la lecture des nouvelles données
	  }	  


	  if (fClignote)
	  {
		Led1 = ~Led1;
		Led2 = ~Led2;
			
		//environs 40 ms
		for (d=0; d<300;d++) Delay();
		Led1 = ~Led1; Led2 = ~Led2;
			
		//environs 40 ms
		for (d=0; d<300;d++) Delay();
	  }

      //--- Application démo Génère des valeurs aléatoires si Sw1 actif
      if(!Sw1)
      {
		 SendDataBuffer[0] = rand();
         for (i=1; i<64; i++)
           SendDataBuffer[i] = SendDataBuffer[i-1]+1;
      }

      //--- Application démo, envoie des données sur transition de Sw2
      if(Sw2_old ^ Sw2)
      {
         Sw2_old = Sw2;
         if(!Sw2)
            Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 
      }
            */


            
   } //--- End while (1)

}/*%%%%%%%%%%%%%%%%%%%%%%%%%%%% END MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*---------------------------------------------------------------------------*-
   Port_Init ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement des ports 
   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Port_Init () 
{
   P0MDOUT = 0x1D;     // SCK (P0.0), MOSI (P0.2),  
                        //MICREL_PINS (P0.3 et P0.4) en push-pull, MIS0 (P0.1), CLK_LAYER (P0.5) et L0_DETECT (P0.6) en open drain
   P0SKIP = 0x08; 		

   P1MDOUT = 0xFF;      // port P1 en sortie numérique (push-pull)
   P1SKIP  = 0xFF;      // skip port P1
 
   //--- Pour application démo ------------------------------------------                      
   P2MDOUT = 0x0C;      // Switch en entrée P.0 & P.1
                        // Led P.2 & P.3 en sortie numérique (push-pull)
   //--------------------------------------------------------------------                      

   P2SKIP  = 0xFF;      // skip port P2
   XBR0 |= 0x02;        // autorise le SPI //0x12 spi+CP0
   XBR1   |= 0x40;      // autorise le fonctionnement du crossbar

} // Port_Init -----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
   SPIInit ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement du bus SPI

      - mode maître
      - clock = 3 MHz
      - clock au repos à '0' et actif sur le flanc montant 
      - mode 4 fils en maître unique

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void SPIInit () 
{
                     //  +------------  x (read only)
                     //  ¦+-----------  mode : 1 = mode Master
                     //  ¦¦+----------  phase du SCK  : 0 = flanc montant
                     //  ¦¦¦+---------  SCK au repos  : 0 = niveau bas
                     //  ¦¦¦¦   +-----  x (read only)
                     //  ¦¦¦¦   ¦+----  x (read only)
                     //  ¦¦¦¦   ¦¦+---  x (read only)
                     //  ¦¦¦¦   ¦¦¦+--  x (read only)
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CFG = 0x40;   //  0100 / 0000  

                     //  +------------  RAZ : flag SPIF
                     //  ¦+-----------  RAZ : flag WCOL
                     //  ¦¦+----------  RAZ : flag MODF
                     //  ¦¦¦+---------  RAZ : flag RXOVRN
                     //  ¦¦¦¦   +-----  NSSMD1 : mode 3 fils un seul maître  
                     //  ¦¦¦¦   ¦+----  NSSMD0 : X
                     //  ¦¦¦¦   ¦¦+---  RAZ : FLAG TXBMT
                     //  ¦¦¦¦   ¦¦¦+--  SPIEN : autorisation du SPI
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CN = 0x01;    //  0000 / 0001  


   SPI0CKR = 3;      // SPI0CKR = (SYSCLK/(2*CLK_SPI))-1
                     //           (24MHz/(2*(3MHz))-1 = 3    
   ESPI0=1;  //Autorisation des interruptions SPI
} // SPIInit ------------------------------------------------------------------		 


/*---------------------------------------------------------------------------*-
Init_int0()
-----------------------------------------------------------------------------
Descriptif: Initialisation de l'interruption INT0 sur bit 2 port 0 actif sur 
transition montante
Entrée : --
Sortie : --

Priorité élevée. Interruption autorisée
-*---------------------------------------------------------------------------*/
void Init_Int0()
{

	//-- Démarrage de la configuration pour INT0 --
	EX0 = 0; 				// Inhibe l'interruption INT0
	//-- Matériel --
	IT0 = 1; 				// Interruption actif sur transition.
	IT01CF = IT01CF & 0xF0; // Clear bit de configuration INT0
							  	   //    +----- Etat Haut
								   //    |+++-- INT0 sur bit 5 du port 0
							  	   //    ||||
	IT01CF = IT01CF | 0x0D; //xxxx1101
	IE0 = 0; // Efface une interruption résiduelle
//	EX0 = 1; //Autorise l'interruption INT0
				   
} // Init_Int0 ----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
SPI0interrupt ()
-----------------------------------------------------------------------------
Descriptif: à chaque fin d'envoi de données, cette fonction est appellée.

Entrée : --
Sortie : --
-*---------------------------------------------------------------------------*/
void SPI0interrupt() interrupt INTERRUPT_SPI0
{
   //Variables locales
   static unsigned char cpt = 1; //démarre de 1 puisque la première données est déjà envoyée
   //=================
   if (SPIF)   //Si les données ont été envoyées
   {
       
      if (cpt<8)  //Si les données n'ont pas toutes été envoyées,
      {
         SPI0DAT = ledcube[cpt][layer_cube];	// Write to spi la prochaine ligne du tableau à l'étage correspondant
         cpt++;   //Incrémentation du compteur
      }
      else
      {

         
         spi_rdy = 1;   //Le flag passe à 1.
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteurcpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteurcpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur

         Micrel_strb = 1;  //latch des données dans les micrel
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 0;

         Micrel_out_en = 0;   //Activation des sorties drivers 

         memory_lock = 0;  //libération de la mémoire du cube
      }
   }

   WCOL = 0;
   MODF = 0;
   RXOVRN = 0;
   SPIF = 0;      //RAZ des Flag d'interruption
} // SPI0interrupt ------------------------------------------------------------ 	   


/*---------------------------------------------------------------------------*-
   Interrupt_Int0()
  -----------------------------------------------------------------------------
   Descriptif: interruption int0 sur front montant averti le main lorsqu'une 
   mesure entre deux intervals est terminée.


   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Int0() interrupt 0
{
 	static bit clk_sync = 0;
	static unsigned char clk_count = 0;	//Pour le tableau
   unsigned char nop;

   Micrel_out_en = 1;   //Inhibition des sorties drivers au démarrage



   if(!clk_sync) 	//Si le clk n'est pas encore synchronisé avec l'étage,
   {
      for (nop = 0; nop<17 ;nop++)     //Attente d'environs 9us!
      {
      }
   }  //Attente!
   			

  
   //nop à  avant de commencer une lecture du programme (attente de stabilisation L0_detect)

   //Si l'étage 0 est actif et que le clk n'est pas encore synchro et 
   //que 8 clk au moins ont déjà été reçus
   
   if (L0_detect && (clk_count > 7) && (clk_sync == 0))   
   {
      
      clk_sync = 1;     //le compteur est synchronisé avec le n° de l'étage actif
      Micrel_out_en = 0;   //Autorisation de l'affichage
      clk_count = 0;
   }

   if (clk_sync)     //Si le clk est synchronisé
   {
     if (clk_count>7)	//Si le clk est de nouveau celui de l'étage 0
     {
         clk_count = 0; //mise à 0 du compteur de clk
     }

     layer_cube = clk_count;     //la variable globale prends la valeur de l'étage en cours de sélection

   //  if (clk_count == 0)  ////////////////////        Montre la détection de l'étage 0
   //  P1= 0xFF;           /////////////////////////
    // P1 = 0x00;         /////////////////////////

     memory_lock = 1;   //Avertissement de mémoire cube bloquée pour affichage

     SPI0DAT =  ledcube[0][clk_count];   // envoi des données via spi aux drivers de l'étage en cours
     //                 couche à écrire
     //ici code!
     
   }



   clk_count++;         //A chaque coup de clk reçu, cette variables est incrémentée




} // int0 interrupt -----------------------------------------------------------


      

/*---------------------------------------------------------------------------*-
*                                     Tracer un texte avec la Fonte 5 x 7 points
*   x1      : 0 à 239
*   y1      : 0 à 319
*   Taille  : Utiliser 1 pour la taille normale , ou >1 pour agrandir les caracteres
*   couleur         : format 16 bits RGB16(r,g,b)    ** Couleur des caractere
*   couleur_arriere : format 16 bits RGB16(r,g,b)    ** Couleur d'arriere plan des caracteres
*************************************************************************************************
*/
void cube_txt(unsigned char layer,side , char* str_ptr)
{
	xdata unsigned char i,j, k, l, m,x,face_nb = 7;                                	// Compteurs
	xdata unsigned int y;
  	xdata char pixelData[5];                                	// enregistre les données du caractere
	
	//enregistrement des données de la structure en ram (car la structure peut très bien être en code...)


//	Address_set(0,0,GCLCDX,GCLCDY);  	//Pour une zone couvrant tout l'écran,

	for(; *str_ptr != '\0'; ++str_ptr, ++x)                 		// Compter jusqu'a la fin du texte
	{

    	if(*str_ptr < 'S') 											// Regarde si le caractere est stocké dans le 1er tableau de caractères (page de 255 bytes)
         	memcpy(pixelData, FONT[*str_ptr - ' '], 5);
	   else if(*str_ptr <= '~') 									// Regarde si le caractere est stocké dans le 2eme tableau de caractères (page de 255 bytes)
         	memcpy(pixelData, FONT2[*str_ptr - 'S'], 5);
	   else
         	memcpy(pixelData, FONT[0], 5);   						// Si caractere non trouvé alors considerer comme espace
			   
      
     
       //sens devant!
     /* for(i=0;i<8;i++)
      {
    	   ledcube [7][i] = 0xFF;//pixelData[0] & (0x01<<i);

      }        */



      /*
	   for(j=0;j<5;j++)  //Pour traiter les 4 bytes provenants de la font
	   {
         
         for(i=0;i<8;i++)	//répéter 8x
         {
            
            if(i<=7) 	//Si le caractère n'est pas encore terminé (en hauteur)
   
       	      ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);    
          	   //ledcube [face_nb][i] |= (pixelData[j] & (0x01<<i))<<(7-(i-j));   
               //ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))<<(i-1); 
         }
      }       */



       




         //////////////////////////
      /*	for(i=0;i<8;i++)  //répéter 8x
         {
            
            if(i<=7) //Si le caractère n'est pas encore terminé (en hauteur)
   
       	      ledcube [face_nb][i] |= (pixelData[0] & (0x80>>i))<<i;        
   
         }    */
         ///////////////////////////////
    //  }

			/*
      	for(i=0;i<8;i++)  //répéter 8x		   0
 		{
   
			ledcube [face_nb][i] |= (pixelData[0] & (0x80>>i))<<i;        
   
      	}  

		for(i=0;i<8;i++)  //répéter 8x		   1
 		{
   			if (i<=1)
			 	ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))>>(1-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))<<(i-1);        
   
      	}  
	   	

		for(i=0;i<8;i++)  //répéter 8x		   2
 		{
   			if (i<=2)
			 	ledcube [face_nb][i] |= (pixelData[2] & (0x80>>i))>>(2-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[2] & (0x80>>i))<<(i-2);        
   
      	}  

		for(i=0;i<8;i++)  //répéter 8x		   3
 		{
   			if (i<=3)
			 	ledcube [face_nb][i] |= (pixelData[3] & (0x80>>i))>>(3-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[3] & (0x80>>i))<<(i-3);        
   
      	}  


		for(i=0;i<8;i++)  //répéter 8x		   4
 		{
   			if (i<=4)
			 	ledcube [face_nb][i] |= (pixelData[4] & (0x80>>i))>>(4-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[4] & (0x80>>i))<<(i-4);        
   
      	}  
			*/


	   	//Code pour afficher le texte sur une face avant du cube
	   	for(j=0;j<5;j++)
		{

		   	for(i=0;i<8;i++)  //répéter 8x		   tout d'un coup
	 		{
	   			if (i<=j)
				 	ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))>>(j-i); 
				else 	
					ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);        
	   
	      	}  
	 	}



	 /*  ledcube [0][0] = 0x00;
      ledcube [1][0] = pixelData[0];
      ledcube [2][0] = pixelData[1];
      ledcube [3][0] = pixelData[2];
      ledcube [4][0] = pixelData[3];
      ledcube [5][0] = pixelData[4];
      ledcube [6][0] = 0x00;
      ledcube [7][0] = 0x00;   */    
          
      
	}
}


/*---------------------------------------------------------------------------*-
   rotat_droite()
  -----------------------------------------------------------------------------
   Descriptif: représente le cube avec une rotation de l'image à 90° à droite 
   si sens = 1, ou à gauche si sens = 0.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void rotat_h(unsigned char** ptr_ledcube,unsigned char** ptr_newcube, bit sens)
{
	//=========Déclarations locales============
	xdata unsigned char i,j,k;		
	//=========================================	

	//note: plus de code pour économiser en temps d'exécution!
		   
	if(sens) 	//Si sens pour rotation image à droite
	{	
	   for(i=0;i<8;i++)    //répéter 8x
		{
			for(j=0;j<8;j++)		//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x		  
	 			{
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | ((ptr_ledcube[k][i]&(1<<j))>>j);    
	   	   }
	 	   }  
	 	}	
	}
	else	  	//Si rotation à gauche
	{
	 	for(i=0;i<8;i++)		//répéter 8x	
		{
		   for(j=0;j<8;j++)  	//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x		 
	 			{
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | ((ptr_ledcube[k][i]&(0x80>>j))>>(7-j));    
	   	   }
		   }  
	 	}		
	}
}


/*---------------------------------------------------------------------------*-
   tabtoface()
  -----------------------------------------------------------------------------
   Descriptif: affiche un tableau sur la face désirée

   Entrée    : (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void tabtoface(unsigned char* ptr_tab,unsigned char** ptr_newcube,unsigned char face_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i;		
	//=========================================	
	
	for (i=0;i<8;i++)    
	{ 					
		ptr_newcube [face_nb][i] = ptr_tab [i]; 	
	}    
}







/*---------------------------------------------------------------------------*-
   anim_cligno()
  -----------------------------------------------------------------------------
   Descriptif: l'état du cube est inversé

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_cligno(unsigned char** ptr_tab,unsigned char** ptr_newcube)
{
	//=========Déclarations locales============
	xdata unsigned char i,j;		
	//=========================================	

	for (i=0;i<8;i++)
	   {   
	     for (j=0;j<8;j++)
	     {
	        ptr_newcube [j][i] = ptr_tab[j][i]^0xFF;    //mise en place de valeur dans le tableau!
	     }
	  }     
	              
	   
}	 

	
/*---------------------------------------------------------------------------*-
   anim_base_up()
  -----------------------------------------------------------------------------
   Descriptif: l'état du cube est inversé

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up(unsigned char** ptr_newcube)
{
	//=========Déclarations locales============
	xdata unsigned char i;
	static xdata unsigned char cpt = 0;		
	//=========================================	

  
	for (i=0;i<8;i++)
  	{ 
     	ptr_newcube [i][cpt] = 0xFF;    //mise en place de valeur dans le tableau!
     	ptr_newcube [i][(cpt-1)%8] = 0x00;    //mise en place de valeur dans le tableau!
  	}    

  	cpt = (cpt+1)%8;

}
	   
	
/*---------------------------------------------------------------------------*-
   anim_base_up_dn()
  -----------------------------------------------------------------------------
   Descriptif: animation de plaque montante, puis descendante.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up_dn(unsigned char** ptr_newcube)
{
	//=========Déclarations locales============
	xdata unsigned char i;
	static xdata unsigned char cpt = 0;
	static bit sens = 0;		
	//=========================================	

	//sens à 1 pour monter, 0 pour descendre
	  
	for (i=0;i<8;i++)
	{ 
		ptr_newcube [i][cpt] = 0xFF;    //mise en place de valeur dans le tableau!
		if (sens)
	    	ptr_newcube [i][(cpt-1)%8] = 0x00;    //mise en place de valeur dans le tableau!
	  	else
	   	ptr_newcube [i][(cpt+1)%8] = 0x00;    //mise en place de valeur dans le tableau!
	}    
	if(cpt == 7)
	 	sens = 0;
	else if (cpt==0) 
	 	sens = 1;
	
	if (sens)
		cpt++;
	else
	   	cpt--;
	
}	


/*---------------------------------------------------------------------------*-
   anim_base_l_r()
  -----------------------------------------------------------------------------
   Descriptif: animation de plaque défillante à droite, puis à gauche.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_l_r(unsigned char** ptr_newcube)
{
	//=========Déclarations locales============
	xdata unsigned char i,j;
	static xdata unsigned char cpt = 0;
	static bit sens = 0;		
	//=========================================	
	
	for (i=0;i<8;i++)          	//répéter 8x
	{ 
		for (j=0;j<8;j++)    	//répéter 8x
		{ 
			if (sens)
	      	ptr_newcube [j] [i] = 0x80>>cpt;	//mise en place de valeur dans le tableau!
	   	else
	         ptr_newcube [j] [i] = 0x01<<cpt; 	//mise en place de valeur dans le tableau!
	  	}
	}
	
	if(cpt == 7) 	//Inversion du sens à chaque butée atteinte
	sens ^= 1;
	  
	cpt = (cpt+1)%8; 	//cpt 0 à 7
	
}
						  

/*---------------------------------------------------------------------------*-
   anim_pluie()
  -----------------------------------------------------------------------------
   Descriptif: animation de pluie

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_pluie(unsigned char** ptr_newcube,  unsigned char anim_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i,j;
	static xdata unsigned char cpt = 0;
	static bit sens = 0;		
	//=========================================	

	        
 	switch(anim_nb)
	{
	   	case 1:
		{
			//Scrolling de l'étage supérieur vers inférieur par copie!
				
			for (j=0;j<7;j++) 	//répéter 6x  (de 6 à 0)
			{ 
			 	for (i=0;i<8;i++)          //répéter 8x 
		  		{ 
			     	//Copie du tableau de l'étage supérieur vers l'étage inférieur!
			   	ptr_newcube [i][j] = ptr_newcube [i][j+1];    	//Scrolling                   
			          
			  	}
			}
			
			
			for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
			{ 
				ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
			}
		}	
	  	break;	 


		case 2: //============================= pluie cube n°2 ==============================               
	 
	  		for (j=0;j<7;j++) 	//répéter 7x  (de 6 à 0)
	  		{ 
	 	   	for (i=0;i<8;i++)          //répéter 8x 
	  			{ 
	          	   //Copie du tableau de l'étage supérieur vers l'étage inférieur!
	
	         	ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                   
	          
	     		}
	  		}
	
	  		if((cpt%2)==0) //une fois sur deux la pluie sera regénérée
	  		{
		   	for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
	     		}
	  		}
	  		cpt++;
		break;



	         
	 //============================= pluie cube new3 ==============================
	  
	   /*
	  //triple scrolling
	    
	  for (j=0;j<7;j++) 	//répéter 6x  (de 6 à 0)
	  { 
	 	   for (i=0;i<8;i++)          //répéter 8x 
	  	{ 
	          	   //Copie du tableau de l'étage supérieur vers l'étage inférieur!
	         ledcube [i][j] = ledcube [i][j+1];    //Scrolling                   
	       // ledcube [i][j+1] = ledcube [i][j+2];    //Scrolling  
	      //  ledcube [i][j+2] = ledcube [i][j+3];    //Scrolling 
	     }
	  }   
	
	
	  main_cpt++;
	
	  if((main_cpt>=1)&&(main_cpt<=3))     //une fois sur huit nouvelle pluie sera générée
	  {
		   for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     { 
	        ledcube [j][7] = rand();	//mise en place de valeur dans le tableau! 
	     }
	  }
	  else if (main_cpt >= 8)
	  {
	     main_cpt = 0;  	
	  }
	  else
	  {
	     for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     { 
	        ledcube [j][7] = 0x00;	//premier étage éteint
	     }
	  }
	
	  Delay_1ms (600);      	      // temporisation 3 seconde
	
	    */
	}
}	