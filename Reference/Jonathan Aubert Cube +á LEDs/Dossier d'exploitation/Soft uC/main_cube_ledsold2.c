/*===========================================================================*=
   CFP - Technique - Bus USB version HID  
   Modèle usbhid : Neuhaus J. adaptation du firmware Silicon Laboratories, Inc.
                   Modèle version 1.1 du 21 juin 2010. 

  -----------------------------------------------------------------------------                 
   Auteur        : Jonathan Aubert   
   Date création : 21 juin 2010
   Modifié le    : 21 juin 2010
   Version       : 1.0
  =============================================================================
   Descriptif: Application cube
                 
               Le fonctionnement de l'application est: 
   
=*===========================================================================*/

//--- Includes ----------------------------------------------------------------
#include <c8051f320.h>
#include "F32x_USB_Primitives.h"
#include <stdlib.h>           	// accès au générateur de nombre aléatoire
#include "FONT5x7.c"             // police de caractères 5*7
#include <string.h>


//Structure pour définir/lire un point dans l'espace
typedef struct
{
	char x;
	char y;
	char z;
} coord;

//Structure de bits pour flags (menu par exemple			
typedef struct
{
 	unsigned int bit_0 : 1;
 	unsigned int bit_1 : 1;
 	unsigned int bit_2 : 1;
 	unsigned int bit_3 : 1;
 	unsigned int bit_4 : 1;
 	unsigned int bit_5 : 1;
 	unsigned int bit_6 : 1;
 	unsigned int bit_7 : 1;
 	unsigned int bit_8 : 1;
 	unsigned int bit_9 : 1;
 	unsigned int bit_10 : 1;
 	unsigned int bit_11 : 1;
 	unsigned int bit_12 : 1;
 	unsigned int bit_13 : 1;
 	unsigned int bit_14 : 1;
 	unsigned int bit_15 : 1;
 	unsigned int bit_16 : 1;
} bit_st;

// ==== Fonctions prototypes ==================================================
void Port_Init();     		// Configure ports
void SPIInit ();          	// init config SPI
void PCA0_Init();				// init du PCA0
void Init_Int0();        	// init INT0
void Init_Int1();				// init INT1
void Init_Timer0();			// init Timer0
void luminosite(unsigned char lum);
void Cube_car(unsigned char ptr_newcube[][8],unsigned char face_nb ,char caract);
void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb);
void anim_base_l_r(unsigned char ptr_newcube[][8], bit new);
void anim_base_up_dn(unsigned char ptr_newcube[][8], bit new);
void anim_base_up(unsigned char ptr_newcube[][8]);
void anim_cligno(unsigned char ptr_tab[][8],unsigned char ptr_newcube[][8]);
void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], bit sens);
void Depl_profond(unsigned char ptr_newcube[][8], bit sens);
void Depl_largeur(unsigned char ptr_newcube[][8], bit sens);
void Depl_hauteur(unsigned char ptr_newcube[][8], bit sens);
void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char face_nb);
void tabtolayer(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char etage_nb);
void Copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
void Clear_cube(unsigned char tab[][8]);
void Or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
void Wr_coord_cube(coord *ptr_coord,bit state,unsigned char ptr_tab[][8]);
bit Rd_coord_cube(coord *ptr_coord,unsigned char ptr_tab[][8]);
void Tab_to_use(unsigned char working_add[][8],unsigned char ptrbuff1[][8],unsigned char ptrbuff2[][8]);


// ==== Equivalences ==========================================================
#define TIMER0_LOAD 60512 		//Délai pour 10ms (Tinc = 2 [us]).
#define CEX0_XBR_BIT 0x01		//bit pour router le CEX0 au port (P0.3 dans ce cas).
#define PCA0CN_ACT_BIT 0x40 	//bit d'activation du PCA0 (PWM dans ce cas).
#define PCA0CPM0_ECOM_BIT 0x40//bit d'activation du comparateur module 0

#define MENU_SIZE 6				//Taille du menu principal

#define LUM_DEFAULT 100		//Luminosité du cube par défaut

#define USB_MODE_NULL 0 	//Si rien est à faire avec le case de l'usb
#define USB_MODE_DRAW 1		//pour le case de l'usb, mode dessin
#define USB_MODE_PWM 2		//pour le case de l'usb, mode PWM (luminosité leds)

// ==== Variables globales ====================================================
code char anim_layer_on[] = 	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
code char chiffre_0 [] =		{0x3C,0x42,0x5A,0x42,0x66,0x5A,0x42,0x3C};
code char chiffre_1 [] = 		{0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x7E};
code char chiffre_2 [] =	 	{0x3C,0x42,0x02,0x04,0x08,0x10,0x20,0x7E};
code char chiffre_3 [] =		{0x3C,0x42,0x02,0x0E,0x0E,0x02,0x42,0x3C};
code char chiffre_4 [] =		{0x04,0x08,0x10,0x28,0x48,0x7E,0x08,0x08};
code char logo_usb [] =			{0x00,0xC3,0xA4,0xA4,0xC4,0x84,0x83,0x00};


//Trames échangées 
code char str_usb_rdy[] = "#ready$";	  		//Trame cube prêt!
code char str_usb_notdry[] = "#notready$";	//Trame cube non-prêt
code char str_usb_pwm[] = "#pwm$";		//Trame de réception PWM
code char str_usb_draw[] = "#draw$";	//Trame de réception image va être reçu
code char str_usb_stop[] = "#stop$";	//trame à recevoirde mode stop

xdata unsigned char (*ptrledcube)[8]; 	//ptr pour mémoire du cube!
bit flag_buffcube1 = 1;		//démarrage sur le tableau 1 (si à 0, ce sera le tableau 2)!
xdata unsigned char layer_cube = 0;
xdata unsigned char pwm_prechg = 0xFF;	//valeur du registre du pwm
xdata unsigned long time_global = 0;

bit flag_pca_cmp_act = 0;	//le cmp du module 0 PCA0 est désactivé de base 
bit memory_lock = 0;               	//indique si mémoire occupée

//FLAG à 1 indique un appui  (gestion à 1 si autorisée)
bit btn_ok = 0, btn_prec = 0, btn_suiv = 0, flag_gestion_btn = 1;	


sbit Micrel_strb = P0^3;
sbit Micrel_out_en = P1^1;
sbit Clk_layer = P0^6;
sbit L0_detect = P1^0;
sbit Sw_prec = P1^2;
sbit Sw_ok = P1^3;
sbit Sw_suiv = P1^4;



/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*                                  MAIN                                       */
/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void main(void)
{
  	//--- Variables locales ----------------------------------------------------
	//Variables utilisées pour affichage
	xdata unsigned char cube_buffer1 [8][8];	 	//variables de traitement avant affichage 
	xdata unsigned char cube_buffer2 [8][8];	 	//variables de traitement avant affichage
	xdata unsigned char (*buff_to_use)[8] = cube_buffer1;	//Tableau à utiliser comme buffer
	//==================================

	xdata unsigned char cube_buff3 [8][8]; 	//Buffer supplémentaire pour calculer de nouvelles images (exemple rotation)

	xdata coord coordpt;	//pour définir un point dans l'espace avec les fonctions Wr/Rd_coord_cube
	xdata unsigned char luminosite_buff = 100;	//buffer pour luminosité cube
	xdata unsigned char i = 0, j = 0;	 			//Compteurs

	//Pour la gestion du menu principale
	xdata unsigned char menu = 0;		//indique le n° du menu sélectionné
	bit run_anim = 0, new_menu = 1, sens_anim_3 = 1;	//flags Utilisés pour la gestion du menu et boutons
	xdata bit_st first_menu = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};  	//Initialisation des flags premier passage menu à 1

  	//Pour la gestion usb!
	xdata unsigned char mode_usb = 0; 	//Type de mode usb (Réception image, luminosité etc...)
	bit usb_mode = 0;		//A 1 si mode usb sélectionnée
	bit first_usb = 1;	//indique si c'est le premier passage en mode usb
  	

	//--------------------------------------------------------------------------

	PCA0MD &= ~0x40;	// Disable Watchdog timer
	Sysclk_Init(); 	// Initialize oscillator inclus spécificité usb
                 		// Clock système sera fixé à 24MHz
	Port_Init();    	// Initialize crossbar and GPIO
	SPIInit ();     	// init config SPI
	Init_Timer0();		// init Timer0
	PCA0_Init();		// Initialisation du PCA0
	Init_Int0();    	// init INT0 
	Init_Int1();
	Usb0_Init();    	// Initialize USB0 (Doit être la dernière routine init car
                 		// autorisation générale de interrupt fait à un moment opportun
                 		// dans cette routine) 

	while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
	ptrledcube = cube_buffer1;	//passage du pointeur sur cube_buffer1


	Micrel_out_en = 1;	//Inhibition des sorties drivers au démarrage
	Micrel_strb = 0;

		 
	  
	for (i=0;i<64;i++)
		SendDataBuffer[i] = 0x00;
	Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : 0	par usb

   EX0 = 1; //Autorise l'interruption INT0 pour démarrage de synchronisation cube!    
   TR0 = 1;	//Démarrage du timer0


	Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser
	Clear_cube(buff_to_use);	 	//effacement du tableau libre			  	
	while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
	ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
	flag_buffcube1^=1;		 	//Le buffer n'est plus le même

   while (1)
   {

	   //=================Test des bouton et gestion du menu==============================
		if (flag_gestion_btn)  	//Si la gestion des boutons est autorisée
		{
			if (btn_ok)				//Si flag touche de confirmation appuyée,
			{
				btn_ok = 0;		//raz du flag
			 	run_anim ^= 1;	//l'animation en cours de sélection va être lancée ou arrêtée
				if(!run_anim)	//Dans le cas d'un arrêt, actualisation du menu
				{
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.	
					luminosite(LUM_DEFAULT);	//La luminosité du cube revient à sa valeur par defaut
				}
			}
			
			if (btn_suiv)	//Sinon, si c'est une simple sélection d'anim suivante.
			{
				btn_suiv = 0;	//raz flag
				if (run_anim)
				{
					luminosite(LUM_DEFAULT);	//La luminosité du cube revient à sa valeur par defaut
					run_anim = 0;  	//l'animation sera stopée, retour à la sélection
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}	
				else
				{
					menu = (menu+1)%MENU_SIZE;	//incrémentation de la sélection d'anim dans le menu
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
			}
			else if (btn_prec)	//Sinon, si c'est une simple sélection anim précédente.
			{
				btn_prec = 0;	//raz flag
	
				if (run_anim)
				{
					luminosite(LUM_DEFAULT);	//La luminosité du cube revient à sa valeur par defaut
					run_anim = 0;  	//l'animation sera stopée, retour à la sélection
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.
				}	
				else if (menu)		//Si le menu n'est pas encore à 0
				{
					menu = (menu-1)%MENU_SIZE;	//décrémentation de la sélection d'anim dans le menu
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
				else	  			//Sinon (menu à 0)
				{
					menu = MENU_SIZE-1;	//Le menu prend la valeur max
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
			}
		}
	  	//====================Fin du test des boutons=============================





		//=========================Affichage du menu===============================

		if (run_anim) 	//Si décision de lancement de l'animation
		{
			
			switch(menu)  	//selon le menu sélectionné
			{
			 	case 0:

					if(time_global>=80)	//Si 80ms écoulées	
					{
						time_global = 0;	//RAZ du time pour timing	
						Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);		//choix du buffer à utiliser
						if (first_menu.bit_0) 	//Si première entrée dans l'anim,
						{
						  	Clear_cube(buff_to_use);	//Le cube est off
						}  	
						anim_base_up(buff_to_use);	//animation de base montante!
						while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
						ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
						flag_buffcube1^=1;			//Avertissement de changement de buffer
					}

				break;
	
			 	case 1:

					if(time_global>=80)	//Si 80ms écoulées	
					{
					  	time_global = 0;	//RAZ du time pour timing
						Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	 
						if (first_menu.bit_1) 	//Si c'est la première image de l'anim,
						{
							Clear_cube(buff_to_use);						//efface le cube							
							tabtolayer(anim_layer_on,buff_to_use,0);	//Copie de la couche à afficher sur l'étage 0
							anim_base_up_dn(buff_to_use, first_menu.bit_1);	//Nouvelle anim
							first_menu.bit_1 = 0;  		//les prochaines images ne seront pas la première								
						}
						else
						{
							anim_base_up_dn(buff_to_use, first_menu.bit_1);	//animation de base up/dn!
						}
					
						while(memory_lock); 				//Attendre libération de la mémoire avant de continuer
						ptrledcube = buff_to_use;		//passage du pointeur sur le nouveau utilisé
						flag_buffcube1^=1;				//Avertissement de changement de buffer
					}
				break;
				case 2:
					if(time_global>=80)	//Si 80ms écoulées	
					{
					  	time_global = 0;	//RAZ du time pour timing
					  	Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	
						if (first_menu.bit_2)
						{
							Clear_cube(buff_to_use);					//Efface le cube
							Clear_cube(cube_buff3);						//efface le cube_buff3							
							tabtoface(anim_layer_on,cube_buff3,0);	//Copie du tableau à afficher sur la face 0	
							rotat_h(cube_buff3,buff_to_use,1); 		//rotation de l'image à gauche (90°)
							anim_base_l_r(buff_to_use,first_menu.bit_2);	//Nouvelle anim
							first_menu.bit_2 = 0;  		//les prochaines images ne seront pas la première	
						}
						else
						{
						 	anim_base_l_r(buff_to_use,first_menu.bit_2);			//Animation
						}
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
						flag_buffcube1^=1;		//Avertissement de changement de buffer
					}

				break;
				case 3:
				if (first_menu.bit_3)		//Si c'est le premier lancement du menu 3,
				{
					first_menu.bit_3 = 0;	//RAZ du flag
					luminosite_buff = 70;  	//Luminosité de départ à 70

					Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	
					  	
					for(i=0;i<8;i++)		  	//allumage des 8 étages
					{
						for(j=0;j<8;j++)
						{
							buff_to_use[j][i] = 0xFF;	//Allumage du cube entier		 	
						}	
					}						
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
					flag_buffcube1^=1;		//Avertissement de changement de buffer				
				}
				else
				{
					if(time_global>=20)	//Si 20ms écoulées	
					{
					  	time_global = 0;	//RAZ du time pour timing
						luminosite(luminosite_buff);	//réglage de la luminosité

						if(luminosite_buff >= 70)	  	//mécanisme d'auto incrémentation/décrémentation
						 	sens_anim_3 = 0;
						else if (luminosite_buff==0) 
						 	sens_anim_3 = 1;
						
						if (sens_anim_3) 	
							luminosite_buff++;
						else
							luminosite_buff--;
					}	
				} 		
				break;
				case 4:
					if(time_global>=100)	//Si 100ms écoulées	
					{
						time_global = 0;	//RAZ du time pour timing
						Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	
						if (first_menu.bit_4) 	//Si première entrée dans le menu,
						{
							Clear_cube(buff_to_use);					//Efface le cube
							first_menu.bit_4 = 0;  	//les prochaines images ne seront pas la première	
						}
						anim_pluie(buff_to_use,2);	//Animation pluie n°2
						
					  	while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
						ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
						flag_buffcube1^=1;			//Avertissement de changement de buffer
					}
				break;
			 	case 5:
					if(!usb_mode)		  	//Si pas le mode usb n'est pas encore actif,
					{
						Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	  	
						Clear_cube(buff_to_use); 	//Efface le cube
						Cube_car(buff_to_use,7, 'D');	//Affiche Data en profondeur
						Cube_car(buff_to_use,5, 'A');
						Cube_car(buff_to_use,3, 'T');	
 						Cube_car(buff_to_use,1, 'A');
						//Déplacement du cube d'1 led sur à droite (centrage des caractères)
						Depl_largeur(buff_to_use,1);
						while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
						ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
						flag_buffcube1^=1;			//Avertissement de changement de buffer
						usb_mode = 1;	  				//Activation du mode USB
					}
				break;			
			}
		}
		else if (new_menu)				//Sinon, si Menu de sélection!!!!!!!!!!!!!!!!!!	
		{
			first_menu.bit_0 = 1;		//RA1 des flag de gestion first anims
			first_menu.bit_1 = 1;
			first_menu.bit_2 = 1;
			first_menu.bit_3 = 1;
			first_menu.bit_4 = 1;
			first_menu.bit_5 = 1;

			Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);		//choix du buffer à utiliser
			Clear_cube(buff_to_use); 	//Clear le buffer

			switch(menu)  	//selon le menu sélectionné
			{			
			 	case 0:	

					tabtoface(chiffre_0,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(chiffre_0,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même
					 					
				break;
	
			 	case 1:
			
					tabtoface(chiffre_1,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(chiffre_1,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même
							
				break;
				case 2:

					tabtoface(chiffre_2,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(chiffre_2,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même

				break;
				case 3:

					tabtoface(chiffre_3,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(chiffre_3,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même

				break;
				case 4:

					tabtoface(chiffre_4,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(chiffre_4,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même

				break;
			 	case 5:

					tabtoface(logo_usb,buff_to_use,3);		//Copie du chiffre à afficher
					tabtoface(logo_usb,buff_to_use,4);	 	//Sur les faces 2 et 3
					while(memory_lock); 			//Attendre libération de la mémoire avant de continuer
					ptrledcube = buff_to_use;	//passage du pointeur sur le buffer utilisé
					flag_buffcube1^=1;		 	//Le buffer n'est plus le même
								
				break;			
			}
			new_menu = 0;	//Le flag de rafraichissement du menu est raz.
	  	}

		//===============================Fin de l'affichage du menu=======================








		//============================Pour sélection du mode usb==========================
			 
		if (usb_mode)	  		//Si le mode usb est sélectionnée
		{
			flag_gestion_btn = 0;	//impossibilité de toucher les boutons	jusqu'à nouvel ordre!

			if(first_usb)	  	//Si c'est le premier dialogue par usb
			{
				strcpy(SendDataBuffer,str_usb_rdy);		//copie du message usb prêt dans le buffer usb	
		 		Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : cube_prêt à recevoir des données
				first_usb = 0;
			}
				
			 
			if (fNewData) 				//Si de nouvelles données sont reçues
		 	{  
				//Acquistion des données
         	Read_receive_Packet(ReceiveDataBuffer, sizeof(ReceiveDataBuffer));
	
				j = ReceiveDataBuffer[0];

				if (mode_usb == USB_MODE_NULL)	//Si aucun ordre actuel,
				{
					if (!strcmp(str_usb_draw,ReceiveDataBuffer))	//Si trame de mode dessin reçue,
					{
						mode_usb	= USB_MODE_DRAW;	//mode de dessin activé	
					}
					else if (!strcmp(str_usb_pwm,ReceiveDataBuffer))	//Sinon, si une luminositée va être reçue
					{
					 	mode_usb = USB_MODE_PWM;	//Accès au pwm
					}
					else if (!strcmp(str_usb_stop,ReceiveDataBuffer))		//Sinon, si trame de stop usb reçue (et que la fin de trame est bien à 0)
					{
						strcpy(SendDataBuffer,str_usb_notdry);			//Copie de trame not ready dans le buffer d'envoi usb	
			 			Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : cube pas prêt à recevoir des données
						mode_usb	= USB_MODE_NULL;	//plus rien à faire dans le case
						luminosite_buff = LUM_DEFAULT;	//La luminosité revient à la valeur par défaut
						luminosite(luminosite_buff);	//Réglage de la nouvelle luminosité
						first_usb = 1;	//en cas de nouvel communication	
					  	usb_mode = 0;	//le mode usb est quitté
						new_menu = 1;	//retour au menu de sélection
						run_anim = 0;	//retour au menu de sélection
						flag_gestion_btn = 1; 	//Communication usb terminée, réacivation des boutons 	
					}
				}
				else 	//Sinon, la donnée reçue est de type donnée à afficher ou nouvelle luminosité,
				{
					switch(mode_usb)	 	//Selon le mode usb choisi via l'application C#,
					{
					 	case USB_MODE_DRAW: 
							Tab_to_use(buff_to_use,cube_buffer1,cube_buffer2);	 	//choix du buffer à utiliser	
						
							for (i=0;i<8;i++)
							{
								for (j=0;j<8;j++)
								{								
									buff_to_use[j][i] = ReceiveDataBuffer[(i*8)+j];	//transfert du buffer de réception usb dans le mémoire buffer
								}
							}
	
							while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
							ptrledcube = buff_to_use;	//passage du pointeur sur le nouveau utilisé
							flag_buffcube1^=1;		//Avertissement de changement de buffer
							mode_usb	= USB_MODE_NULL;	// IL n'y aura plus rien à faire dans le case avant autre commande
						break;

						case USB_MODE_PWM:	//En cas de PWM à recevoir

							luminosite_buff = 0;
							luminosite_buff += (ReceiveDataBuffer[0]-'0')*100;
							luminosite_buff += (ReceiveDataBuffer[1]-'0')*10;
							luminosite_buff += ReceiveDataBuffer[2]-'0';
							//Enregistrement de la valeur reçue
							luminosite(luminosite_buff);	//Réglage de la nouvelle luminosité
							  
							mode_usb	= USB_MODE_NULL;	//Plus rien à faire dans le case
						break;
					}
				}
				fNewData = 0; //Quittance la lecture des nouvelles données	
			}
				
		}	 

		//======================================Fin  du mode USB==========================

     
   } //--- End while (1)

}/*%%%%%%%%%%%%%%%%%%%%%%%%%%%% END MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*---------------------------------------------------------------------------*-
   Port_Init ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement des ports 
   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Port_Init () 
{

 	// P0.0  -  SCK  (SPI0), Push-Pull,  Digital
   // P0.1  -  MISO (SPI0), Open-Drain, Digital
   // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
   // P0.3  -  Skipped,     Push-Pull,  Digital
   // P0.4  -  Skipped,     Open-Drain, Digital
   // P0.5  -  Skipped,     Open-Drain, Digital
   // P0.6  -  Skipped,     Open-Drain, Digital
   // P0.7  -  Skipped,     Open-Drain, Digital
	
	// P1.0  -  Skipped,     Open-Drain, Digital
   // P1.1  -  [CEX0 (PCA)],  Push-Pull,  Digital
   // P1.2  -  Skipped,     Open-Drain, Digital
   // P1.3  -  Skipped,     Open-Drain, Digital
   // P1.4  -  Skipped,     Open-Drain, Digital
   // P1.5  -  Unassigned,  Open-Drain, Digital
   // P1.6  -  Unassigned,  Open-Drain, Digital
   // P1.7  -  Unassigned,  Open-Drain, Digital
   // P2.0  -  Unassigned,  Open-Drain, Digital
   // P2.1  -  Unassigned,  Open-Drain, Digital
   // P2.2  -  Unassigned,  Open-Drain, Digital
   // P2.3  -  Unassigned,  Open-Drain, Digital

// MICREL_PINS (P0.3(Micrel_strb)) en push-pull, MIS0 (P0.1), Clk_layer (P0.6) 
// et btn_detect (P0.7) en open drain	
	P0MDOUT = 0x00;	//PORT P0 en open drain// 0x0D;    	// SCK (P0.0), MOSI (P0.2),  
	
	P0SKIP = 0xF8;			// Skip P0

   P1MDOUT = 0x00;	//PORT P1 en OPEN DRAIN// 0x02;      // port P1 en open drain sauf Micrel_out_en (P1.1)
   P1SKIP  = 0x1D;      // skip port P1														                    

   XBR0 |= 0x02;        // autorise le SPI 
   XBR1   |= 0x40;      // autorise le fonctionnement du crossbar 

} // Port_Init -----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
   SPIInit ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement du bus SPI

      - mode maître
      - clock = 3 MHz
      - clock au repos à '0' et actif sur le flanc montant 
      - mode 4 fils en maître unique

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void SPIInit () 
{
                     //  +------------  x (read only)
                     //  ¦+-----------  mode : 1 = mode Master
                     //  ¦¦+----------  phase du SCK  : 0 = flanc montant
                     //  ¦¦¦+---------  SCK au repos  : 0 = niveau bas
                     //  ¦¦¦¦   +-----  x (read only)
                     //  ¦¦¦¦   ¦+----  x (read only)
                     //  ¦¦¦¦   ¦¦+---  x (read only)
                     //  ¦¦¦¦   ¦¦¦+--  x (read only)
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CFG = 0x40;   //  0100 / 0000  

                     //  +------------  RAZ : flag SPIF
                     //  ¦+-----------  RAZ : flag WCOL
                     //  ¦¦+----------  RAZ : flag MODF
                     //  ¦¦¦+---------  RAZ : flag RXOVRN
                     //  ¦¦¦¦   +-----  NSSMD1 : mode 3 fils un seul maître  
                     //  ¦¦¦¦   ¦+----  NSSMD0 : X
                     //  ¦¦¦¦   ¦¦+---  RAZ : FLAG TXBMT
                     //  ¦¦¦¦   ¦¦¦+--  SPIEN : autorisation du SPI
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CN = 0x01;    //  0000 / 0001  


   SPI0CKR = 3;      // SPI0CKR = (SYSCLK/(2*CLK_SPI))-1
                     //           (24MHz/(2*(3MHz))-1 = 3    
   ESPI0=1;  //Autorisation des interruptions SPI
} // SPIInit ------------------------------------------------------------------		 


/*---------------------------------------------------------------------------*-
   PCA0_Init ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du PCA0 en mode PWM 8bits
   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void PCA0_Init()
{
    PCA0CPM0  = 0x42;	//PCA en mode PWM 8bits		
    PCA0CPH0  = 0xFF;  	//valeur de préchargement = MAX
}



/*---------------------------------------------------------------------------*-
Init_int0()
-----------------------------------------------------------------------------
Descriptif: Initialisation de l'interruption INT0 sur bit 6 port 0 actif sur 
transition montante
Entrée : --
Sortie : --

Priorité élevée. Interruption autorisée
-*---------------------------------------------------------------------------*/
void Init_Int0()
{

	//-- Démarrage de la configuration pour INT0 --
	EX0 = 0; 				// Inhibe l'interruption INT0
	//-- Matériel --
	IT0 = 1; 				// Interruption actif sur transition.
	IT01CF = IT01CF & 0xF0; // Clear bit de configuration INT0
							  	   //    +----- Etat Haut
								   //    |+++-- INT0 sur bit 6 du port 0
							  	   //    ||||
	IT01CF = IT01CF | 0x0E; //xxxx1110
	IE0 = 0; // Efface une interruption résiduelle
	PX0=1;		//Priority maximum!
//	EX0 = 1; //Autorise l'interruption INT0
				   
} // Init_Int0 ----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
Init_int1()
-----------------------------------------------------------------------------
Descriptif: Initialisation de l'interruption INT0 sur bit 7 port 0 actif sur 
transition descendante
Entrée : --
Sortie : --

Priorité élevée. Interruption autorisée
-*---------------------------------------------------------------------------*/
void Init_Int1()
{

	//-- Démarrage de la configuration pour INT1 --
	EX1 = 0; 				// Inhibe l'interruption INT1
	//-- Matériel --
	IT1 = 1; 				// Interruption actif sur transition.
	IT01CF = IT01CF & 0x0F; // Clear bit de configuration INT1
							//    +----- Etat haut
							//    |+++-- INT1 sur bit 7 du port 0
							//    ||||
	IT01CF = IT01CF | 0xF0; //	  1111xxxx
	IE1 = 0; // Efface une interruption résiduelle
	EX1 = 1; //Autorise l'interruption INT1
				   
} // Init_Int1 ----------------------------------------------------------------




/*---------------------------------------------------------------------------*-
SPI0interrupt ()
-----------------------------------------------------------------------------
Descriptif: à chaque fin d'envoi de données, cette fonction est appellée.

Entrée : --
Sortie : --
-*---------------------------------------------------------------------------*/
void Interrupt_Spi() interrupt INTERRUPT_SPI0
{
   //Variables locales
   static unsigned char cpt = 1; //démarre de 1 puisque la première données est déjà envoyée
   //=================
   if (SPIF)   //Si les données ont été envoyées
   {     
      if (cpt<8)  //Si les données n'ont pas toutes été envoyées,
      {
		// Write to spi la prochaine ligne du tableau à l'étage correspondant
         SPI0DAT = ptrledcube[cpt][layer_cube];	
         cpt++;   //Incrémentation du compteur
      }
      else
      {
  
         cpt = 1; //RAz du compteur		//attente de sécurité avant de latcher les données

         Micrel_strb = 1;  //latch des données dans les micrel pendant un certain temps à 1
         Micrel_strb = 1;	//controlé à 
         Micrel_strb = 0;

         //Micrel_out_en = 0; 	//Activation des sorties drivers (le PWM se charge de l'état)
		/*	if (flag_pca_deact)		//Si le pca était désactivé avant la communication
			{
			 	PCA0CPM0 &= PCA0CPM0_ECOM_BIT;	//désactivation du PCA0
			}	*/
		/*	if(flag_pca_cmp_act)	  	//Si le cmp du PCA était activé avant la communication
			{
				PCA0CPH0 = pwm_prechg; 		//Préchargement du PWM
			}
			else
			{
				PCA0CPM0 &= ~PCA0CPM0_ECOM_BIT;	//Désactivation du cmp du module 0 PCA0	
			}
								*/
			XBR1 |= CEX0_XBR_BIT;		//pin CEX0 (ici PWM commun à Micrel_out_en) connecté
		  	PCA0CN |= PCA0CN_ACT_BIT;	//Activation du PWM
         memory_lock = 0;  //libération de la mémoire du cube
      }
   }

   WCOL = 0;
   MODF = 0;
   RXOVRN = 0;
   SPIF = 0;      //RAZ des Flag d'interruption
} // SPI0interrupt ------------------------------------------------------------ 	   


/*---------------------------------------------------------------------------*-
   Interrupt_Int0()
  -----------------------------------------------------------------------------
   Descriptif: interruption int0 sur front montant pour la détection du clk 
   des étages (800 [Hz]).


   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Int0() interrupt INTERRUPT_INT0
{
 	static bit clk_sync = 0;
	static unsigned char clk_count = 0;	//Pour le tableau
	unsigned char nop;
 
 	XBR1 &= ~CEX0_XBR_BIT;	//pin CEX0 (ici PWM commun à Micrel_out_en) déconnecté
   Micrel_out_en = 1;   	//Inhibition des sorties drivers au démarrage
	PCA0CN &= ~PCA0CN_ACT_BIT;	//Arrêt du PWM
	PCA0L = 0x00;	//Reset du compteur interne au PWM

/* if(!(PCA0CPM0 & PCA0CPM0_ECOM_BIT))	//Si le PCA est désactivé,
	{
	 	flag_pca_deact = 1;
	}
	else
	{
		flag_pca_deact = 0;
	}			 */


   if(!clk_sync) 	//Si le clk n'est pas encore synchronisé avec l'étage,
   {
      for (nop = 0; nop<40 ;nop++)     //Attente d'environs 20us!
      {								 	//(attente de stabilisation L0_detect)
      }
   }  //Attente!
  		

  
   //Si l'étage 0 est actif et que le clk n'est pas encore synchro et 
   //que 8 clk au moins ont déjà été reçus
   if (L0_detect && (clk_count > 7) && (clk_sync == 0))   
   {
      
      clk_sync = 1;     //le compteur est synchronisé avec le n° de l'étage actif
    //  Micrel_out_en = 0;   //Autorisation de l'affichage
      clk_count = 0;
   }

   if (clk_sync)     //Si le clk est synchronisé
   {
     if (clk_count>7)	//Si le clk est de nouveau celui de l'étage 0
     {
         clk_count = 0; //mise à 0 du compteur de clk
     }

     layer_cube = clk_count;     //la variable globale prends la valeur de l'étage en cours de sélection

   //  if (clk_count == 0)  ////////////////////        Montre la détection de l'étage 0
   //  P1= 0xFF;           /////////////////////////
    // P1 = 0x00;         /////////////////////////

     memory_lock = 1;   //Avertissement de mémoire cube bloquée pour affichage
		SPI0DAT = ptrledcube[0][clk_count];  // envoi des données via spi aux drivers de l'étage en cours
     //                 couche à écrire
     //ici code!
     
   }



   clk_count++;	//A chaque coup de clk reçu, cette variables est incrémentée




} // int0 interrupt -----------------------------------------------------------



/*---------------------------------------------------------------------------*-
   Interrupt_Int1()
  -----------------------------------------------------------------------------
   Descriptif: interruption int1 sur front montant averti en cas d'appui de
   bouton poussoir


   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Int1() interrupt INTERRUPT_INT1
{	 
	if(flag_gestion_btn)	//Si la gestion des boutons est activée,
	{
		 if (!Sw_ok)		//Si un appui est constaté sur le bouton ok (priorité)
		  	btn_ok = 1;	  	//Passage du flag correspondant à 1.
		 else if (!Sw_suiv)	//Sinon, si c'est le btn suivant
		 	btn_suiv = 1;	
		 else 				//Sinon btn précédent
		 	btn_prec = 1;	
	}	
} // int0 interrupt -----------------------------------------------------------


/*---------------------------------------------------------------------------*-
   interrupt_timer0()
  -----------------------------------------------------------------------------
   Descriptif: interruption du timer0 toutes les 10ms. 
	permet de gérer le temps d'affichage

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Timer0() interrupt INTERRUPT_TIMER0
{	
	//--- Variables locales ----------------------------------------------------- 
  	//--------------------------------------------------------------------------- 
 
  	TR0 = 0;               		//Stop le timer 
  	TH0 = TIMER0_LOAD / 256;	//Recharge la valeur initiale 
  	TL0 = TIMER0_LOAD % 256;   
  	TR0 = 1;               		//Démarre le timer 

	//Incrémentation de la variable temporelle du programme (main).
	time_global+=10; 
	

} // Interrupt_Timer0 ----------------------------------------------------------
      

/*---------------------------------------------------------------------------*-
   Cube_car()
  -----------------------------------------------------------------------------
   Descriptif:  Tracer un caractère avec la Fonte 5 x 7 points (provenant de
	l'écran LCD couleur Chinois...)	sur la face choisie!


   Entrée    : Pointeur sur le tableau 2D (cube); 
		(unsigned char) face où la font sera appliquée ;(char) caractère
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Cube_car(unsigned char ptr_newcube[][8],unsigned char face_nb ,char caract)
{
 	xdata unsigned char i,j;		// Compteurs
  	xdata char pixelData[5];                                	// enregistre les données du caractere
	

// Regarde si le caractere est stocké dans le 1er tableau de caractères (page de 255 bytes)
 	if(caract < 'S') 		
      	memcpy(pixelData, FONT[caract - ' '], 5);
//Sinon, regarde si le caractere est stocké dans le 2eme tableau de caractères (page de 255 bytes)
   else if(caract <= '~') 			
      	memcpy(pixelData, FONT2[caract - 'S'], 5);
   else
      	memcpy(pixelData, FONT[0], 5);	// Si caractere non trouvé alors considerer comme espace
		   
   
  
	//Code pour afficher le texte sur la face avant du cube
	for(j=0;j<5;j++)
	{
	   for(i=0;i<8;i++)  //répéter 8x		   tout d'un coup
 		{
   		if (i<=j)
			 	ptr_newcube [face_nb][i] |= (pixelData[j] & (0x80>>i))>>(j-i); 
			else 	
				ptr_newcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);        
   
      }  
 	}
}



/*---------------------------------------------------------------------------*-
   rotat_h()
  -----------------------------------------------------------------------------
   Descriptif: représente le cube avec une rotation de l'image à 90° à droite 
   si sens = 1, ou à gauche si sens = 0.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], bit sens)
{
	//=========Déclarations locales============
	xdata unsigned char i,j,k;		
	//=========================================	

	//note: plus de code pour économiser en temps d'exécution!
		   
	if(sens) 	//Si sens pour rotation image à gauche
	{	
		for(i=0;i<8;i++)    //répéter 8x
		{
		  	for(j=0;j<8;j++)		//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x (bit par ligne)		  
	 			{
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | ((ptr_ledcube[k][i]&(1<<j))>>j);    
	   	 	}
	    	}  
	 	}	
	}
	else	  	//Si rotation à droite
	{
	 	for(i=0;i<8;i++)		//répéter 8x	
		{
		 	for(j=0;j<8;j++)  	//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x (bit par ligne)		 
	 			{
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]>>1) | ((ptr_ledcube[k][i]&(0x80>>j))<<j);	    
	   	  	} 													  
	   	}  
	 	}		
	}
}


/*---------------------------------------------------------------------------*-
   tabtoface()
  -----------------------------------------------------------------------------
   Descriptif: copie un tableau sur la face désirée

   Entrée    : (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char face_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i;		
	//=========================================	
	
	for (i=0;i<8;i++)    
	{ 					
		ptr_newcube [face_nb][7-i] = ptr_tab [i]; 	
	}    
}



/*---------------------------------------------------------------------------*-
   tabtolayer()
  -----------------------------------------------------------------------------
   Descriptif: copie un tableau sur l'étage désirée

   Entrée    : (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void tabtolayer(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char etage_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i;		
	//=========================================	
	
	for (i=0;i<8;i++)    
	{ 					
		ptr_newcube [i][etage_nb] = ptr_tab [i]; 	
	}    
}

	
/*---------------------------------------------------------------------------*-
   anim_base_up()
  -----------------------------------------------------------------------------
   Descriptif: plateau montant

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up(unsigned char ptr_newcube[][8])
{
	//=========Déclarations locales============
	xdata unsigned char i;
	static xdata unsigned char cpt = 0;		
	//=========================================	

  
	for (i=0;i<8;i++)
  	{ 
     	ptr_newcube [i][cpt] = 0xFF;    //mise en place de valeur dans le tableau!
     	ptr_newcube [i][(cpt-1)%8] = 0x00;    //mise en place de valeur dans le tableau!
  	}    

  	cpt = (cpt+1)%8;

}
	   
	
/*---------------------------------------------------------------------------*-
   anim_base_up_dn()
  -----------------------------------------------------------------------------
   Descriptif: animation de l'étage 0 montant, puis descendant.

   Entrée    : (bit) new pour indiquer si nouvelle animation
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up_dn(unsigned char ptr_newcube[][8], bit new)
{
	//=========Déclarations locales============
	//xdata unsigned char i;
	static xdata unsigned char cpt = 0;
	static bit sens = 1;		
	//=========================================	

	//sens à 1 pour monter, 0 pour descendre

	if (new)		//Si nouvelle anim,
	{
		 cpt = 0;		//Redémarrage du cycle d'anim
		 sens = 1;
	}
	else
	{
		Depl_hauteur(ptr_newcube, sens);	//Déplacement en hauteur effectué!
	}
			 
	if(cpt == 7)
	 	sens = 0;
	else if (cpt==0) 
	 	sens = 1;
	
	if (sens)
		cpt++;
	else
		cpt--;
	
}	 



/*---------------------------------------------------------------------------*-
   anim_base_l_r()
  -----------------------------------------------------------------------------
   Descriptif: animation de plaque défillante à droite, puis à gauche.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_l_r(unsigned char ptr_newcube[][8], bit new)
{
	//=========Déclarations locales============
	static xdata unsigned char cpt = 0;
	static bit sens = 1;		
	//=========================================	
	

	if (new)		//Si nouvelle anim,
	{
		 cpt = 0;		//Redémarrage du cycle d'anim
		 sens = 1;
	}
	else
	{
		Depl_largeur(ptr_newcube,sens);	//Déplacement de l'image en largeur
	}

	if(cpt == 7) 	//Inversion du sens à chaque butée atteinte
	{
		sens ^= 1;
		cpt++;
	}  
	cpt = (cpt+1)%8; 	//cpt 0 à 7
	
}						   
						  

/*---------------------------------------------------------------------------*-
   anim_pluie()
  -----------------------------------------------------------------------------
   Descriptif: animation de pluie

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i,j;
	static xdata unsigned char cpt = 0;	
	//=========================================	

	        
 	switch(anim_nb)
	{
		case 1:
		{
			Depl_hauteur(ptr_newcube,0);	//Déplacement du cube vers le bas!
			
			for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
			{ 
				ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
			}
		}	
	  	break;	 


		case 2: //============================= pluie cube n°2 ==============================               
	 
			for (j=0;j<7;j++) 	//répéter 7x  (de 6 à 0)
	  		{ 
	 	   		for (i=0;i<8;i++)          //répéter 8x 
	  			{ 
	          	   //Copie du tableau de l'étage supérieur vers l'étage inférieur!
	         		ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                       
	     		}
	  		}

	  		if((cpt%2)==0) //une fois sur deux la pluie sera regénérée
	  		{
		   	for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
	     		}
	  		}
			else		//L'autre fois sur deux, 
			{

			}
	  		cpt++;
		break;


	 	case 3:
	         
	 	//============================= pluie cube n3 ==============================
	    
			for (j=0;j<7;j++) 	//répéter 7x  (de 6 à 0)
	  		{ 
	 	   	for (i=0;i<8;i++)          //répéter 8x 
	  			{ 
	          	   //Copie du tableau de l'étage supérieur vers l'étage inférieur!
	         		ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                       
	     		}
	  		}
	
	  		cpt++;
	
	  		if((cpt>=1)&&(cpt<=3))     //une fois sur huit nouvelle pluie sera générée
	  		{
		   		for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = rand();	//mise en place de valeur dans le tableau! 
	     		}
	  		}
		  	else if (cpt >= 8)
		  	{
		     	cpt = 0;  	
		  	}
	  		else
	  		{
	     		for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = 0x00;	//premier étage éteint
	     		}
	  		}
			break;	
	}
}	  	   

/*---------------------------------------------------------------------------*-
   Copy_cube()
  -----------------------------------------------------------------------------
   Descriptif: copie un tableau source 2D dans un tableau dest 2D 

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab_dst[j][i] = tab_src[j][i];	//copie des bytes			 	
		}	
	}	
}


/*---------------------------------------------------------------------------*-
   Or_cube()
  -----------------------------------------------------------------------------
   Descriptif: n'allume que les points à 1 du tableau source dans celui 
   de destination.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab_dst[j][i] |= tab_src[j][i];		//OR des bytes			 	
		}	
	}	
}

/*---------------------------------------------------------------------------*-
   Clear_cube()
  -----------------------------------------------------------------------------
   Descriptif: éteint un cube. (mise à 0 de toutes les variable du tableau).

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Clear_cube(unsigned char tab[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab[j][i] = 0x00;	//mise à 0 des bytes			 	
		}	
	}	
}



/*---------------------------------------------------------------------------*-
   wr_coord_cube()
  -----------------------------------------------------------------------------
   Descriptif: met dans l'état désiré le bit correspondant à la led choisie 
   dans un tableau "de cube".

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Wr_coord_cube(coord *ptr_coord,bit state,unsigned char ptr_tab[][8])
{
  	xdata char x = ptr_coord->x;
  	xdata char y = ptr_coord->y;
  	xdata char z = ptr_coord->z;

	if(x&&y&&z&&(x<5)&&(y<5)&&(z<5)&&(x>-5)&&(y>-5)&&(z>-5))	//Si le point n'est pas sur un axe (0) et qu'il est situé dans l'espace du cube
	{
		x = (x>0)? 4-x:3-x;
		y = (y>0)? y+3:y+4;
		z = (z>0)? 4-z:3-z;		
		if(state)
		{
			ptr_tab[z][y] |= (0x01<<x);
		}
		else
		{
		 	ptr_tab[z][y] &= (~(0x01<<x));
		}
		//ptr_tab[z][y] |= ((state)?0xFF:0x00)&(0x01<<x);
	}
}  	 



/*---------------------------------------------------------------------------*-
   Rd_coord_cube()
  -----------------------------------------------------------------------------
   Descriptif: lis et retourne l'état de la led concernée dans la matrice.

   Entrée    : --
   Sortie    : bit à 1 si le bit (led) concerné est à 1.
-*---------------------------------------------------------------------------*/
bit Rd_coord_cube(coord *ptr_coord,unsigned char ptr_tab[][8])
{
  	xdata char x = ptr_coord->x;
  	xdata char y = ptr_coord->y;
  	xdata char z = ptr_coord->z;

	if(x&&y&&z&&(x<5)&&(y<5)&&(z<5)&&(x>-5)&&(y>-5)&&(z>-5))	//Si le point n'est pas sur un axe (0) et qu'il est situé dans l'espace du cube
	{
		x = (x>0)? 4-x:3-x;
		y = (y>0)? y+3:y+4;
		z = (z>0)? 4-z:3-z;		

		return (bit)(ptr_tab[z][y]&(0x01<<x));
	}
}  	 

	 
	 
/*---------------------------------------------------------------------------*-
   luminosite()
  -----------------------------------------------------------------------------
   Descriptif: un paramètre de 0 à 100 est passé afin de définir la valeur du PWM
	100 = luminosité max, 0 = éteint! 

   Entrée    : (unsigned char)  luminosité du cube de 0 à 100
   Sortie    : --
-*---------------------------------------------------------------------------*/
void luminosite(unsigned char lum)
{  	
//	if	(lum == 100)	//Si la luminosité maximale est demandée,
//	{	
	//	flag_pca_cmp_act = 0;	
	//	PCA0CPM0 &= ~PCA0CPM0_ECOM_BIT; //désactivation du cmp du module 0 PCA0

//	}
//	else
//	{
		pwm_prechg = ((unsigned int)lum*255/100);	//conversion du % en 
																//valeur de préchargement PWM
	//	PCA0CPM0 |= PCA0CPM0_ECOM_BIT; 				//Activation du PCA0
//		flag_pca_cmp_act = 1;
//	}
}	   
	 


/*---------------------------------------------------------------------------*-
Init_Timer0()
-----------------------------------------------------------------------------
Descriptif: Initialisation du timer0 avec incrémentation toutes les 2 [us].
Entrée : --
Sortie : --
-*---------------------------------------------------------------------------*/
void Init_Timer0()
{			
	
	TR0 = 0; 	//Stop le timer
	ET0 = 0; 	//Inhibe l'interruption du timer
	//--- Mode de fonctionnement du timer 0

	TMOD &= 0xF0;		// 		reset initialisation timer 0
				  	   	//     +----- Pas de gate externe
				  	   	//     |+---- Fonction Temporisation
				  	   	// 	 ||++-- Mode 1 16 bits
				  			// 	 ||||
	TMOD |= 0x01;   	// xxxx0010

	CKCON &= ~0x07;   	// clear des bits pour config prescaler

                   	//         +---- Prédiviseur activé 								
                   	//         |++-- Système clock / 48 donc incréments 
                   	//         ||| 							toutes les 1 us.
	CKCON |= 0x02;  	// 	xxxx0010  
	
	TL0 = TIMER0_LOAD/256; 	
	TH0 = TIMER0_LOAD%256;	//Charge la valeur initiale 
	   
	
	TF0 = 0; //Clear une interruption résiduelle
	ET0 = 1; // Autorise l'interruption du timer 0

} // Init_Timer0 --------------------------------------------------------------


/*---------------------------------------------------------------------------*-
   Tab_to_use()
  -----------------------------------------------------------------------------
   Descriptif: indique selon le flag d'utilisation du tableau en cours quel
		buffer utiliser en retournant le pointeur associé au buffer non-utilisé
		dans working_add.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Tab_to_use(unsigned char working_add[][8],unsigned char ptrbuff1[][8],unsigned char ptrbuff2[][8])
{
	if (flag_buffcube1)		//Si le buff1 est utilisé
	{
		working_add = ptrbuff2;	//le tableau de travail sera le buff2
	} 	 		
	else				//Sinon,
	{
	  	working_add = ptrbuff1;	//le tableau de travail sera le buff2
	}
}



/*---------------------------------------------------------------------------*-
   Depl_profond()
  -----------------------------------------------------------------------------
   Descriptif: déplace le contenu du cube vers l'avant (sens = 0) 
	ou l'arrière (sens = 1)

   Entrée    :	Pointeur sur le tableau à modifier, (bit) pour le sens.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Depl_profond(unsigned char ptr_newcube[][8], bit sens)
{
 	xdata char i,j;

	for (i=0;i<8;i++)          	//répéter 8x (étage)
	{ 
		if(sens)	 	//Si dépacement vers l'arrière
		{
			for (j=0;j<8;j++)    	//répéter 8x (ligne)
			{ 
				if (j == 7)				//si la valeur de j est maximum au tableau,
				{
					ptr_newcube [j] [i] = 0x00; 	//écriture de 0 en memoire pour éviter débordement
				}
				else
				{
		  			ptr_newcube [j] [i] = ptr_newcube [j+1] [i];	//décalage des bytes!
				}
		  	}
		}
		else			//Sinon,
		{ 
			for (j=7;j>=0;j--)    	//répéter 8x (ligne)
			{      	
				if (j == 0)	  	//si la valeur de j est minimum au tableau,
				{
					ptr_newcube [j] [i] = 0x00;
				}
				else
				{
					ptr_newcube [j] [i] = ptr_newcube [j-1] [i]; //décalage des bytes!
				}
			}
		}
	}
}



/*---------------------------------------------------------------------------*-
   Depl_largeur()
  -----------------------------------------------------------------------------
   Descriptif: déplace le contenu du cube vers la droite (sens = 1) 
	ou la gauche (sens = 0)

   Entrée    : Pointeur sur le tableau 2D à modifier, (bit) pour le sens.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Depl_largeur(unsigned char ptr_newcube[][8], bit sens)
{
 	xdata unsigned char i,j;

	for (i=0;i<8;i++)          	//répéter 8x (étage)
	{ 
		for (j=0;j<8;j++)    	//répéter 8x (ligne)
		{ 
			if (sens)				//si décalage à droite
			{
				ptr_newcube [j] [i] = ptr_newcube [j] [i]>>1;	//décalage à droite
			}
			else
			{
				ptr_newcube [j] [i] = ptr_newcube [j] [i]<<1;	//décalage à gauche
			}
	  	}
	}
}


/*---------------------------------------------------------------------------*-
   Depl_hauteur()
  -----------------------------------------------------------------------------
   Descriptif: déplace le contenu du cube vers le haut (sens = 1) 
	ou la base (sens = o)

   Entrée    : Pointeur sur le tableau à modifier, (bit) pour le sens.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Depl_hauteur(unsigned char ptr_newcube[][8], bit sens)
{
 	xdata char i,j;

	if (!sens)				//Si décalage descente choisie
	{
		for (i=0;i<8;i++)         	//répéter 8x (étage)
		{ 
			for (j=0;j<8;j++)    	//répéter 8x (ligne)
			{ 		
				if (i == 7)	// pour éviter de sortir de la zone de mémoire
					ptr_newcube [j] [i] = 0x00;	
				else
					ptr_newcube [j] [i] = ptr_newcube [j] [i+1];	//Descente
		  	}
		}
	}
	else			//Si Montée choisie
	{
		for (i=7;i>=0;i--)         	//répéter 8x (étage)
		{ 
			for (j=0;j<8;j++)    	//répéter 8x (ligne)
			{ 		
				if (i == 0)	// pour éviter de sortir de la zone de mémoire
					ptr_newcube [j] [i] = 0x00;	
				else
					ptr_newcube [j] [i] = ptr_newcube [j] [i-1];	//Montée
		  	}
		}
	}
}
