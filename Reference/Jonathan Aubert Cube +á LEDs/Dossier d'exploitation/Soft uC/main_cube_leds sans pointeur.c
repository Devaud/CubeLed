/*===========================================================================*=
   CFP - Technique - Bus USB version HID  
   Modèle usbhid : Neuhaus J. adaptation du firmware Silicon Laboratories, Inc.
                   Modèle version 1.1 du 21 juin 2010. 
  -----------------------------------------------------------------------------                 
   Auteur        : Neuhaus J.    
   Date création : 21 juin 2010
   Modifié le    : 21 juin 2010
   Version       : 1.0
  =============================================================================
   Descriptif: Application support/exemple. 
               L'application Windows associée est F320_usbdid_WinDemo.  
                 
               Le fonctionnement de l'application est: 
   
               Sur l'application windows F320_usbdid_WinDemo 2 boutons de 
               commande définissent l'état des leds du kit F320 de SiLabs.
               Un troisième bouton permet d'activer le mode clignotement qui
               agira en sus de l'état de commande des leds.
   
               Un packet de données composé de 64 bytes est générés quand le 
               switch 1 du Kit Silabs est activé. Les valeurs sont consécutives
               et de type modulo 256 à partir d'une première valeur aléatoire.
               
               Les données sont envoyées sur une transition du switch 2 du kit
               Au niveau de l'application Windows la réception de données
               inverse l'état du témoin et les données sont actualisées au 
               niveau de la grille d'affichage. La réception de données sans 
               changement de valeur n'aura pas d'incidence sur l'application 
               Windows.
               
               A noter que l'application Windows de test HIdTestAPI permet
               aussi de tester l'application du kit, mais les opérations
               devront être faite manuellement au niveau des fenêtres de buffer  
=*===========================================================================*/

//--- Includes ----------------------------------------------------------------
#include <c8051f320.h>
#include "F32x_USB_Primitives.h"
#include <stdlib.h>           	// accès au générateur de nombre aléatoire
#include "Delay.h"               // unité gestion temporisation
#include "FONT5x7.c"             // police de caractères 5*7
#include <string.h>
#include "F320_FlashUtils.h"

// ==== Fonctions prototypes ==================================================
void Port_Init();     		// Configure ports
void SPIInit ();          	// init config SPI
void PCA0_Init();				// init du PCA0
void Init_Int0();        	// init INT0
void Init_Int1();				// init INT1
void Init_Timer0();			// init Timer0
void luminosite(unsigned char lum);
void cube_txt(unsigned char layer,side , char* str_ptr); //écriture de txt
void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb);
void anim_base_l_r(unsigned char ptr_newcube[][8]);
void anim_base_up_dn(unsigned char ptr_newcube[][8]);
void anim_base_up(unsigned char ptr_newcube[][8]);
void anim_cligno(unsigned char ptr_tab[][8],unsigned char ptr_newcube[][8]);
void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], bit sens);
void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char face_nb);
void copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
void clear_cube(unsigned char tab[][8]);
void or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8]);
void wr_coord_cube(char x,char y,char z,bit state,unsigned char ptr_tab[][8]);
bit Cmp_ss_chaine (char ss_chaine [], char chaine []);


// ==== Equivalences ==========================================================
#define TIMER0_LOAD 60512 	//Délai pour 10ms (Tinc = 2 [us]).
#define CEX0_XBR_BIT 0x01		//bit pour router le CEX0 au port (P0.3 dans ce cas).
#define PCA0CN_ACT_BIT 0x40 	//bit d'activation du PCA0 (PWM dans ce cas).
#define MENU_SIZE 5	//Taille du menu principal

#define TRM_STOP_CHAR '$'	//Le caractère de fin de trame

// ==== Variables globales ====================================================
code char str_usb_rdy[] = "#ready$";
code char str_usb_spec[] = "#spec;";	//Début de trame de spécification

xdata unsigned char ledcube [8][8]; 	//tableau pour cube!
xdata unsigned char layer_cube = 0;
xdata unsigned char pwm_prechg = 0xFF;	//valeur du registre du pwm
xdata unsigned long time_global = 0;

bit spi_rdy = 0;
bit memory_lock = 0;                   //indique si mémoire occupée
bit btn_ok = 0, btn_prec = 0, btn_suiv = 0, flag_gestion_btn = 1;	
										//FLAG à 1 indique un appui  (gestion à 1 si autorisée)


sbit Micrel_strb = P0^3;
sbit Micrel_out_en = P1^1;
sbit Clk_layer = P0^6;
sbit L0_detect = P1^0;
sbit Sw_prec = P1^2;
sbit Sw_ok = P1^3;
sbit Sw_suiv = P1^4;

//--- Pour application démo ---------------------------------------------------
sbit Sw1  = P2^0;                    
sbit Sw2  = P2^1;                       
sbit Led1 = P2^2;  
sbit Led2 = P2^3;
bit fClignote=0;

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
/*                                  MAIN                                       */
/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
void main(void)
{
  	//--- Variables locales ----------------------------------------------------
	xdata unsigned char pt_virg = 0;	//Pour le traitement de trame par usb
	xdata unsigned char cube_buffer1 [8][8];	 	//variables de traitement avant affichage
	xdata unsigned char cube_buffer2 [8][8];	 	//variables de traitement avant affichage
	xdata unsigned char luminosite_buff = 100;
	xdata unsigned char i = 0, j = 0, menu = 0;
	xdata unsigned char tab_tst[8];
	bit run_anim = 0, new_menu = 1, sens_anim_4 = 1;	//flags Utilisés pour la gestion du menu et boutons

	bit usb_mode = 0;		//A 1 si mode usb sélectionnée
	bit first_usb = 1;	//indique si c'est le premier passage en mode usb
	bit first_menu_4 = 1;	//indique si c'est le premier passage dans le menu 4
	xdata int d;

	FLADDR add_flash = 0x8080;	//Adresse en flash
	//--------------------------------------------------------------------------

	PCA0MD &= ~0x40;	// Disable Watchdog timer
	Sysclk_Init(); 	// Initialize oscillator inclus spécificité usb
                 		// Clock système sera fixé à 24MHz
	Port_Init();    	// Initialize crossbar and GPIO
	SPIInit ();     	// init config SPI
	Init_Timer0();		// init Timer0
	PCA0_Init();		// Initialisation du PCA0
	Init_Int0();    	// init INT0 
	Init_Int1();
	Usb0_Init();    	// Initialize USB0 (Doit être la dernière routine init car
                 		// autorisation générale de interrupt fait à un moment opportun
                 		// dans cette routine) 


//  	Led1=0; Led2=0;
//   	Sw2_old=Sw2;


	Micrel_out_en = 1;	//Inhibition des sorties drivers au démarrage
	Micrel_strb = 0;
	spi_rdy = 1;

	clear_cube(ledcube);	//La mémoire d'affichage du cube est mise à 0.

        /*
                    anim1
   for (i = 0; i<8;i++)
    { 
      ledcube [0][i] = 0xFF;    //mise en place de valeur dans le tableau!
      ledcube [1][i] = 0x00;
      ledcube [2][i] = 0x00;
      ledcube [3][i] = 0x00;
      ledcube [4][i] = 0x00;
      ledcube [5][i] = 0x00;
      ledcube [6][i] = 0x00;
      ledcube [7][i] = 0x00;
   }    
               */




       	   /*
   ledcube [0][7] = 0x01;    //mise en place de valeur dans le tableau!
   ledcube [1][7] = 0x02;
   ledcube [2][7] = 0x04;
   ledcube [3][7] = 0x08;
   ledcube [4][7] = 0x10;
   ledcube [5][7] = 0x20;
   ledcube [6][7] = 0x40;
   ledcube [7][7] = 0xFF;
                
   ledcube [0][1] = 0x00;    //mise en place de valeur dans le tableau!
   ledcube [1][1] = 0x00;
   ledcube [2][1] = 0x00;
   ledcube [3][1] = 0x00;
   ledcube [4][1] = 0x00;
   ledcube [5][1] = 0x00;
   ledcube [6][1] = 0x00;
   ledcube [7][1] = 0x00;

   ledcube [0][6] = 0x00;    //mise en place de valeur dans le tableau!
   ledcube [1][6] = 0x00;
   ledcube [2][6] = 0x00;
   ledcube [3][6] = 0x00;
   ledcube [4][6] = 0x00;
   ledcube [5][6] = 0x00;
   ledcube [6][6] = 0x00;
   ledcube [7][6] = 0x00;
    */
   /*ledcube [0][0] = 0xFF;    //mise en place de valeur dans le tableau!
   ledcube [1][0] = 0xFF;
   ledcube [2][0] = 0xFF;
   ledcube [3][0] = 0xFF;
   ledcube [4][0] = 0xFF;
   ledcube [5][0] = 0xFF;
   ledcube [6][0] = 0xFF;
   ledcube [7][0] = 0xFF;              
   //SPI0DAT =  ledcube[0][etage_cube];   // écriture de l'étage 0
   
           */
    /*
    ledcube [0][0] = 0xFF;    //mise en place de valeur dans le tableau!
   ledcube [1][0] = 0xFF;
   ledcube [2][0] = 0xFF;
   ledcube [3][0] = 0xFF;
   ledcube [4][0] = 0xFF;
   ledcube [5][0] = 0xFF;
   ledcube [6][0] = 0xFF;
   ledcube [7][0] = 0xFF;      
      */
	 		       tab_tst [0] = 0xAB;    //mise en place de valeur dans le tableau!
 	tab_tst [1] = 0x02;
   tab_tst [2] = 0x04;
   tab_tst [3] = 0x08;
   tab_tst [4] = 0x10;
   tab_tst [5] = 0x20;
   tab_tst [6] = 0x40;      
   tab_tst [7] = 0x80;    //mise en place de valeur dans le tableau!
//		  tabtoface(tab_tst,ledcube,3);
//	      tabtoface(tab_tst,ledcube,4);
		 
	  
		for (i=0;i<64;i++)
			 		SendDataBuffer[i] = 0x00;
			Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : 0	par usb


   EX0 = 1; //Autorise l'interruption INT0 pour démarrage de synchronisation cube!    
   TR0 = 1;	//Démarrage du timer0



		       
//	FLASH_Write (FLADDR dest, char *src, unsigned numbytes);        
	  
   while (1)
   {

	   //=================Test des bouton et gestion du menu==============================
		if (flag_gestion_btn)  	//Si la gestion des boutons est autorisée
		{
			if (btn_ok)		//Si flag touche de confirmation appuyée,
			{
				btn_ok = 0;	//raz du flag
			 	run_anim ^= 1;	//l'animation en cours de sélection va être lancée ou arrêtée
				if(!run_anim)	//Dans le cas d'un arrêt, actualisation du menu
				{
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.	
				}
				Led1 ^=1;
			}
			
			if (btn_suiv)	//Sinon, si c'est une simple sélection d'anim suivante.
			{
				btn_suiv = 0;	//raz flag
				if (run_anim)
				{
					run_anim = 0;  	//l'animation sera stopée, retour à la sélection
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}	
				else
				{
					menu = (menu+1)%MENU_SIZE;	//incrémentation de la sélection d'anim dans le menu
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
			}
			else if (btn_prec)	//Sinon, si c'est une simple sélection anim précédente.
			{
				btn_prec = 0;	//raz flag
	
				if (run_anim)
				{
					run_anim = 0;  	//l'animation sera stopée, retour à la sélection
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.
				}	
				else if (menu)		//Si le menu n'est pas encore à 0
				{
					menu = (menu-1)%MENU_SIZE;	//décrémentation de la sélection d'anim dans le menu
					new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
				else	  			//Sinon (menu à 0)
				{
					menu = MENU_SIZE-1;	//Le menu prend la valeur max
				 	new_menu = 1;	//Flag de rafraichissement menu à 1.
				}
			}
		}
	  	//====================Fin du test des boutons=============================




		//=========================Affichage du menu===============================

		if (run_anim) 	//Si décision de lancement de l'animation
		{
			
			switch(menu)  	//selon le menu sélectionné
			{
			 	case 0:
					luminosite(100);
				//	clear_cube(cube_buffer2);
				//	tabtoface(tab_tst,cube_buffer2,3);
	     		//	tabtoface(tab_tst,cube_buffer2,4);
					if(time_global>=80)	//Si 800ms écoulée	
					{
					  	time_global = 0;	//RAZ du time pour timing
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						anim_base_up(ledcube); 	//animation de base montante!
							 	//changement de l'image
					}

			//	  	while(memory_lock); //Attendre libération de la mémoire avant de continuer
						  		  
				//  	copy_cube(cube_buffer2,ledcube);

		 		 	//Delay_1ms (200);              	// temporisation 3 seconde	 */

				break;
	
			 	case 1:

					if(time_global>=80)	//Si 800ms écoulée	
					{
					  	time_global = 0;	//RAZ du time pour timing
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						anim_base_up_dn(ledcube);

					}
				break;
				case 2:
					if(time_global>=80)	//Si 800ms écoulée	
					{
					  	time_global = 0;	//RAZ du time pour timing
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						anim_base_l_r(ledcube);

					}

				break;
				case 3:
				if (first_menu_4)		//Si c'est le premier lancement du menu,
				{
					first_menu_4 = 0;	//RAZ du flag
					luminosite_buff = 70;
					while(memory_lock); 		//Attendre libération de la mémoire avant de continuer

					for(i=0;i<8;i++)		  	//64x
					{
						for(j=0;j<8;j++)
						{
							ledcube[j][i] = 0xFF;	//Allumage du cube entier		 	
						}	
					}	

				
				}
				else
				{
					if(time_global>=20)	//Si 100ms écoulée	
					{
					  	time_global = 0;	//RAZ du time pour timing
						luminosite(luminosite_buff);	//réglage de la luminosité

						if(luminosite_buff >= 70)	  	//mécanisme d'auto incrémentation/décrémentation
						 	sens_anim_4 = 0;
						else if (luminosite_buff==0) 
						 	sens_anim_4 = 1;
						
						if (sens_anim_4)
							luminosite_buff++;
						else
							luminosite_buff--;
	

					}	
				} 		
				break;
			 	case 4:
					luminosite(40);
					if(!usb_mode)		  	//Si pas le mode usb n'est pas encore actif,
					{
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						clear_cube(ledcube);
						while(memory_lock); 		//Attendre libération de la mémoire avant de continuer
						cube_txt(5,5,"d");
						usb_mode = 1;
					}
				break;			
			}
		}
		else if (new_menu)	//Sinon, si réactualisation nécessaire	
		{
		first_menu_4 = 1;		//RAZ du flag de gestion first anim4
			clear_cube(ledcube);
			switch(menu)  	//selon le menu sélectionné
			{			
				clear_cube(ledcube);	
			 	case 0:	
					 	cube_txt(0,1,"0");						
				break;
	
			 	case 1:							
						cube_txt(0,1,"1");
				break;
				case 2:
					 	cube_txt(0,1,"2");
				break;
				case 3:
						cube_txt(0,1,"3"); 
				break;
			 	case 4:
						cube_txt(0,1,"*");
						
				break;			
			}

			new_menu = 0;	//Le flag de rafraichissement du menu est raz.
	  	}

		//===============================Fin de l'affichage du menu=======================





		//============================Pour sélection du mode usb==========================
			 
		if (usb_mode)	  		//Si le mode usb est sélectionnée
		{
			flag_gestion_btn = 0;	//impossibilité de toucher les boutons	jusqu'à nouvel ordre!

			if(first_usb)	  	//Si c'est le premier dialogue par usb
			{
				strcpy(SendDataBuffer,str_usb_rdy);		//copie du message usb prêt dans le buffer usb	
		 		Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : cube_prêt à recevoir des données
				first_usb = 0;
			//	for (i=0;i<64;i++)
			 //		SendDataBuffer[i] = 0x00;
			//	Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : cube_prêt à recevoir des données
			}
				
			 
			if (fNewData) 				//Si de nouvelles données sont reçues
		 	{  
				//Acquistion des données
         	Read_receive_Packet(ReceiveDataBuffer, sizeof(ReceiveDataBuffer));
	
					j = ReceiveDataBuffer[0];

				if (Cmp_ss_chaine (str_usb_spec, ReceiveDataBuffer)) 	//Si la trame reçue est de type spec,
				{
					
					//analyse de la trame reçue par extraction des champs
				  i = 0;
				/*	while(ReceiveDataBuffer[i]!= TRM_STOP_CHAR)		// Tant que la trame n'est pas terminée------------
					{
			
						if (ReceiveDataBuffer[i] == ';') 	//Si un point virgule est détectée,
						{
						 	pt_virg++;	//incrémentation du compteur comma
						}
			
						i++;						//Le compteur i est incrémenté
						switch(pt_virg)// Identification du champ traité selon le nombre de pt virgule
						{
							case 1: //	Pour le champ n°1,
									
								while (ReceiveDataBuffer[i] != ';')		//tant que le prochain pt virgule n'est pas détecté
								{					
									latitude [e++] = str [i++];		//enregistrement de la latitude
								}	
								comma++;					//incrémentation de comma
							break;
							case 2:		//Pour le champ n°2,


										 
							break;

						}	  Mettre ici le code nécessaire à l'extraction de la chaine de caractères			
					}	*/


					//Fin de l'analyse

					cube_txt(0,1,"P");
					
				  	//	usb_mode = 0;	//Fin de communication usb
					//	run_anim = 0;	//repassage au sous_menu
					//	first_usb = 1;	//en cas de nouvel communication
	
				  	usb_mode = 0;	//le mode usb est quitté
					new_menu = 1;	//retour au menu de sélection
					run_anim = 0;	//retour au menu de sélection
					flag_gestion_btn = 1; 	//Communication usb terminée, réacivation des boutons 	
				}
			}
			fNewData = 0; //Quittance la lecture des nouvelles données		
		}



		//===========================





	/*	else
		{
			for (i=0;i<64;i++)
			 		SendDataBuffer[i] = 0x00;
			Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 	//Envoi : 0
		}	 */

					 

		//======================================Fin  du mode USB==========================



		//  wr_coord_cube(1,2,3,1,cube_buffer);


		  //========================Animation de rotation image===========================
	/*	  
		  clear_cube(cube_buffer);
		  rotat_h(ledcube,cube_buffer,Sw_ok);	//rotation de l'image du cube sur la droite
		  while(memory_lock); //Attendre libération de la mémoire avant de continuer
				  		  
		  copy_cube(cube_buffer,ledcube);

		  Delay_1ms (200);              	// temporisation 3 seconde	 */
		 //===================================Fin de l'anim==================================


	
		//  while(memory_lock); //Attendre libération de la mémoire avant de continuer
			//anim_base_up(ledcube);
			//anim_base_up_dn(ledcube);
			//anim_cligno(ledcube,ledcube);
		//	anim_pluie(ledcube, 1);
		   	
   



//	  	memcpy(Tab2, Tab1, sizeof Tab2);
    
     
     /* 
	   line = line>>1;

     if (!line)
     {
         line = 0x80;
     }

     for (i=0;i<8;i++)
     {
         ledcube[i][etage_cube] = line;
     }
           	  */
      	  //==================diagonale cube =======================
/*	  for (i=0;i<8;i++)
	  { 
	
	
	     ledcube [main_cpt][i] ^= 0xFF;    //mise en place de valeur dans le tableau!
	     ledcube [(++main_cpt)%8][i] = 0x00;    //mise en place de valeur dans le tableau!
	
	  }    
	
	  Delay_1ms (500);                      // temporisation 3 seconde   */
	       
	      
	                 
				   /*   
    // if (spi_rdy)    //Si un étage n'est pas en cours d'affichage
    // {
///     SPI0DAT = ledcube[0][etage_cube];   // écriture de l'étage 0 
   //  spi_rdy = 0; 
   //  }   
     
  //   Delay_1ms (70);                      // temporisation 3 seconde                                                      
      //--- Application démo, Exemple réception de données
       */


      /*
      	ledcube [0][0] ^= 0xFF;    //mise en place de valeur dans le tableau!
         ledcube [1][0] ^= 0xFF;
         ledcube [2][0] ^= 0xFF;
         ledcube [3][0] ^= 0xFF;
         ledcube [4][0] ^= 0xFF;
         ledcube [5][0] ^= 0xFF;
         ledcube [6][0] ^= 0xFF;
         ledcube [7][0] ^= 0xFF;    */
         
          
     




   


     // 0x00, 0x04, 0x02, 0x7F, 0x00


    

      //i=(i+1)%8;
      
      
             /*ledcube [0][i] = ^0xFF;    //mise en place de valeur dans le tableau!
         ledcube [1][i] = 0x00;
         ledcube [2][i] = 0x00;
         ledcube [3][i] = 0x00;
         ledcube [4][i] = 0x00;
         ledcube [5][i] = 0x00;
         ledcube [6][i] = 0x00;
         ledcube [7][i] = 0x00;

                                     */       
	  //Si de nouvelles données ont été reçues
     /* if (fNewData)
	  {  
	    //Transfert les données reçues dans le buffer
        Read_receive_Packet(ReceiveDataBuffer, sizeof(ReceiveDataBuffer));
      
		//Traitement des données reçus
	    if (ReceiveDataBuffer[0] == 1) 
	      Led1 = 1;  
	    else 
	      Led1 = 0;
	    if (ReceiveDataBuffer[1] == 1)

        v          	      Led2 = 1;   
	    else 
	      Led2 = 0;
	
		fClignote=(ReceiveDataBuffer[63] > 0);
			  
	  	fNewData = 0; //Quittance la lecture des nouvelles données
	  }	  


	  if (fClignote)
	  {
		Led1 = ~Led1;
		Led2 = ~Led2;
			
		//environs 40 ms
		for (d=0; d<300;d++) Delay();
		Led1 = ~Led1; Led2 = ~Led2;
			
		//environs 40 ms
		for (d=0; d<300;d++) Delay();
	  }

      //--- Application démo Génère des valeurs aléatoires si Sw1 actif
      if(!Sw1)
      {
		 SendDataBuffer[0] = rand();
         for (i=1; i<64; i++)
           SendDataBuffer[i] = SendDataBuffer[i-1]+1;
      }

      //--- Application démo, envoie des données sur transition de Sw2
      if(Sw2_old ^ Sw2)
      {
         Sw2_old = Sw2;
         if(!Sw2)
            Write_send_Packet (SendDataBuffer, sizeof(SendDataBuffer)); 
      }
            */


            
   } //--- End while (1)

}/*%%%%%%%%%%%%%%%%%%%%%%%%%%%% END MAIN %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*---------------------------------------------------------------------------*-
   Port_Init ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement des ports 
   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Port_Init () 
{

 	// P0.0  -  SCK  (SPI0), Push-Pull,  Digital
   // P0.1  -  MISO (SPI0), Open-Drain, Digital
   // P0.2  -  MOSI (SPI0), Push-Pull,  Digital
   // P0.3  -  Skipped,     Push-Pull,  Digital
   // P0.4  -  Skipped,     Open-Drain, Digital
   // P0.5  -  Skipped,     Open-Drain, Digital
   // P0.6  -  Skipped,     Open-Drain, Digital
   // P0.7  -  Skipped,     Open-Drain, Digital
	
	// P1.0  -  Skipped,     Open-Drain, Digital
   // P1.1  -  [CEX0 (PCA)],  Push-Pull,  Digital
   // P1.2  -  Skipped,     Open-Drain, Digital
   // P1.3  -  Skipped,     Open-Drain, Digital
   // P1.4  -  Skipped,     Open-Drain, Digital
   // P1.5  -  Unassigned,  Open-Drain, Digital
   // P1.6  -  Unassigned,  Open-Drain, Digital
   // P1.7  -  Unassigned,  Open-Drain, Digital
   // P2.0  -  Unassigned,  Open-Drain, Digital
   // P2.1  -  Unassigned,  Open-Drain, Digital
   // P2.2  -  Unassigned,  Open-Drain, Digital
   // P2.3  -  Unassigned,  Open-Drain, Digital


	P0MDOUT = 0x0D;    	// SCK (P0.0), MOSI (P0.2),  
                        // MICREL_PINS (P0.3(Micrel_strb)) en push-pull, MIS0 (P0.1), Clk_layer (P0.6) et btn_detect (P0.7) en open drain		
	P0SKIP = 0xF8;			// Skip 

   P1MDOUT = 0x02;      // port P1 en open drain sauf Micrel_out_en (P1.1)
   P1SKIP  = 0x1D;      // skip port P1														 
 
   //--- Pour application démo ------------------------------------------                      
   P2MDOUT = 0x0C;      // Switch en entrée P.0 & P.1
                        // Led P.2 & P.3 en sortie numérique (push-pull)
   //--------------------------------------------------------------------                      

   P2SKIP = 0xFF;      // skip port P2
   XBR0 |= 0x02;        // autorise le SPI 
   XBR1   |= 0x40;      // autorise le fonctionnement du crossbar 

} // Port_Init -----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
   SPIInit ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du mode de fonctionnement du bus SPI

      - mode maître
      - clock = 3 MHz
      - clock au repos à '0' et actif sur le flanc montant 
      - mode 4 fils en maître unique

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void SPIInit () 
{
                     //  +------------  x (read only)
                     //  ¦+-----------  mode : 1 = mode Master
                     //  ¦¦+----------  phase du SCK  : 0 = flanc montant
                     //  ¦¦¦+---------  SCK au repos  : 0 = niveau bas
                     //  ¦¦¦¦   +-----  x (read only)
                     //  ¦¦¦¦   ¦+----  x (read only)
                     //  ¦¦¦¦   ¦¦+---  x (read only)
                     //  ¦¦¦¦   ¦¦¦+--  x (read only)
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CFG = 0x40;   //  0100 / 0000  

                     //  +------------  RAZ : flag SPIF
                     //  ¦+-----------  RAZ : flag WCOL
                     //  ¦¦+----------  RAZ : flag MODF
                     //  ¦¦¦+---------  RAZ : flag RXOVRN
                     //  ¦¦¦¦   +-----  NSSMD1 : mode 3 fils un seul maître  
                     //  ¦¦¦¦   ¦+----  NSSMD0 : X
                     //  ¦¦¦¦   ¦¦+---  RAZ : FLAG TXBMT
                     //  ¦¦¦¦   ¦¦¦+--  SPIEN : autorisation du SPI
                     //  ¦¦¦¦   ¦¦¦¦
   SPI0CN = 0x01;    //  0000 / 0001  


   SPI0CKR = 3;      // SPI0CKR = (SYSCLK/(2*CLK_SPI))-1
                     //           (24MHz/(2*(3MHz))-1 = 3    
   ESPI0=1;  //Autorisation des interruptions SPI
} // SPIInit ------------------------------------------------------------------		 


/*---------------------------------------------------------------------------*-
   PCA0_Init ()
  -----------------------------------------------------------------------------
   Descriptif: Initialisation du PCA0 en mode PWM 8bits
   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void PCA0_Init()
{
    PCA0CPM0  = 0x42;	//PCA en mode PWM 8bits		
    PCA0CPH0  = 0xFF;  	//valeur de préchargement = MAX
}



/*---------------------------------------------------------------------------*-
Init_int0()
-----------------------------------------------------------------------------
Descriptif: Initialisation de l'interruption INT0 sur bit 6 port 0 actif sur 
transition montante
Entrée : --
Sortie : --

Priorité élevée. Interruption autorisée
-*---------------------------------------------------------------------------*/
void Init_Int0()
{

	//-- Démarrage de la configuration pour INT0 --
	EX0 = 0; 				// Inhibe l'interruption INT0
	//-- Matériel --
	IT0 = 1; 				// Interruption actif sur transition.
	IT01CF = IT01CF & 0xF0; // Clear bit de configuration INT0
							  	   //    +----- Etat Haut
								   //    |+++-- INT0 sur bit 6 du port 0
							  	   //    ||||
	IT01CF = IT01CF | 0x0E; //xxxx1110
	IE0 = 0; // Efface une interruption résiduelle
//	EX0 = 1; //Autorise l'interruption INT0
				   
} // Init_Int0 ----------------------------------------------------------------


/*---------------------------------------------------------------------------*-
Init_int1()
-----------------------------------------------------------------------------
Descriptif: Initialisation de l'interruption INT0 sur bit 7 port 0 actif sur 
transition descendante
Entrée : --
Sortie : --

Priorité élevée. Interruption autorisée
-*---------------------------------------------------------------------------*/
void Init_Int1()
{

	//-- Démarrage de la configuration pour INT1 --
	EX1 = 0; 				// Inhibe l'interruption INT1
	//-- Matériel --
	IT1 = 1; 				// Interruption actif sur transition.
	IT01CF = IT01CF & 0x0F; // Clear bit de configuration INT1
							//    +----- Etat haut
							//    |+++-- INT1 sur bit 7 du port 0
							//    ||||
	IT01CF = IT01CF | 0xF0; //	  1111xxxx
	IE1 = 0; // Efface une interruption résiduelle
	EX1 = 1; //Autorise l'interruption INT1
				   
} // Init_Int1 ----------------------------------------------------------------




/*---------------------------------------------------------------------------*-
SPI0interrupt ()
-----------------------------------------------------------------------------
Descriptif: à chaque fin d'envoi de données, cette fonction est appellée.

Entrée : --
Sortie : --
-*---------------------------------------------------------------------------*/
void Interrupt_Spi() interrupt INTERRUPT_SPI0
{
   //Variables locales
   static unsigned char cpt = 1; //démarre de 1 puisque la première données est déjà envoyée
   //=================
   if (SPIF)   //Si les données ont été envoyées
   {
       
      if (cpt<8)  //Si les données n'ont pas toutes été envoyées,
      {
         SPI0DAT = ledcube[cpt][layer_cube];	// Write to spi la prochaine ligne du tableau à l'étage correspondant
         cpt++;   //Incrémentation du compteur
      }
      else
      {

         
         spi_rdy = 1;   //Le flag passe à 1.
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur
         cpt = 0; //RAz du compteur		//attente de sécurité avant de latcher les données

         Micrel_strb = 1;  //latch des données dans les micrel pendant un certain temps à 1
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 1;
         Micrel_strb = 0;

         //Micrel_out_en = 0;    	//Activation des sorties drivers (le PWM se charge de l'état)
			PCA0CPH0 = pwm_prechg; 	//Préchargement du PWM
			XBR1 |= CEX0_XBR_BIT;		//pin CEX0 (ici PWM commun à Micrel_out_en) connecté
		  	PCA0CN |= PCA0CN_ACT_BIT;	//Activation du PWM

         memory_lock = 0;  //libération de la mémoire du cube
      }
   }

   WCOL = 0;
   MODF = 0;
   RXOVRN = 0;
   SPIF = 0;      //RAZ des Flag d'interruption
} // SPI0interrupt ------------------------------------------------------------ 	   


/*---------------------------------------------------------------------------*-
   Interrupt_Int0()
  -----------------------------------------------------------------------------
   Descriptif: interruption int0 sur front montant pour la détection du clk 
   des étages (800 [Hz]).


   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Int0() interrupt INTERRUPT_INT0
{
 	static bit clk_sync = 0;
	static unsigned char clk_count = 0;	//Pour le tableau
	unsigned char nop;
 
 	XBR1 &= ~CEX0_XBR_BIT;	//pin CEX0 (ici PWM commun à Micrel_out_en) déconnecté
   Micrel_out_en = 1;   	//Inhibition des sorties drivers au démarrage
	PCA0CN &= ~PCA0CN_ACT_BIT;	//Arrêt du PWM
	PCA0L = 0x00;	//Reset du compteur interne au PWM


   if(!clk_sync) 	//Si le clk n'est pas encore synchronisé avec l'étage,
   {
      for (nop = 0; nop<17 ;nop++)     //Attente d'environs 9us!
      {
      }
   }  //Attente!
   			

  
   //nop à  avant de commencer une lecture du programme (attente de stabilisation L0_detect)

   //Si l'étage 0 est actif et que le clk n'est pas encore synchro et 
   //que 8 clk au moins ont déjà été reçus
   
   if (L0_detect && (clk_count > 7) && (clk_sync == 0))   
   {
      
      clk_sync = 1;     //le compteur est synchronisé avec le n° de l'étage actif
    //  Micrel_out_en = 0;   //Autorisation de l'affichage
      clk_count = 0;
   }

   if (clk_sync)     //Si le clk est synchronisé
   {
     if (clk_count>7)	//Si le clk est de nouveau celui de l'étage 0
     {
         clk_count = 0; //mise à 0 du compteur de clk
     }

     layer_cube = clk_count;     //la variable globale prends la valeur de l'étage en cours de sélection

   //  if (clk_count == 0)  ////////////////////        Montre la détection de l'étage 0
   //  P1= 0xFF;           /////////////////////////
    // P1 = 0x00;         /////////////////////////

     memory_lock = 1;   //Avertissement de mémoire cube bloquée pour affichage

     SPI0DAT =  ledcube[0][clk_count];   // envoi des données via spi aux drivers de l'étage en cours
     //                 couche à écrire
     //ici code!
     
   }



   clk_count++;         //A chaque coup de clk reçu, cette variables est incrémentée




} // int0 interrupt -----------------------------------------------------------



/*---------------------------------------------------------------------------*-
   Interrupt_Int1()
  -----------------------------------------------------------------------------
   Descriptif: interruption int1 sur front montant averti en cas d'appui de
   bouton poussoir


   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Int1() interrupt INTERRUPT_INT1
{	 
	if(flag_gestion_btn)	//Si la gestion des boutons est activée,
	{
		 if (!Sw_ok)		//Si un appui est constaté sur le bouton ok (priorité)
		  	btn_ok = 1;	  	//Passage du flag correspondant à 1.
		 else if (!Sw_suiv)	//Sinon, si c'est le btn suivant
		 	btn_suiv = 1;	
		 else 				//Sinon btn précédent
		 	btn_prec = 1;	
	}	
} // int0 interrupt -----------------------------------------------------------


/*---------------------------------------------------------------------------*-
   interrupt_timer0()
  -----------------------------------------------------------------------------
   Descriptif: interruption du timer0 toutes les 10ms. permet de gérer le temps d'affichage

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void Interrupt_Timer0() interrupt INTERRUPT_TIMER0
{	
	//--- Variables locales ----------------------------------------------------- 
  	//--------------------------------------------------------------------------- 
 
  	TR0 = 0;               		//Stop le timer 
  	TH0 = TIMER0_LOAD / 256;	//Recharge la valeur initiale 
  	TL0 = TIMER0_LOAD % 256;   
  	TR0 = 1;               		//Démarre le timer 

	//Incrémentation de la variable temporelle du programme (main).
	time_global+=10; 
	

} // Interrupt_Timer0 ----------------------------------------------------------
      

/*---------------------------------------------------------------------------*-
*                                     Tracer un texte avec la Fonte 5 x 7 points
*   x1      : 0 à 239
*   y1      : 0 à 319
*   Taille  : Utiliser 1 pour la taille normale , ou >1 pour agrandir les caracteres
*   couleur         : format 16 bits RGB16(r,g,b)    ** Couleur des caractere
*   couleur_arriere : format 16 bits RGB16(r,g,b)    ** Couleur d'arriere plan des caracteres
*************************************************************************************************
*/
void cube_txt(unsigned char layer, side , char* str_ptr)
{
   	xdata unsigned char i,j, k, l, m,x,face_nb = 7;                                	// Compteurs
	xdata unsigned int y;
  	xdata char pixelData[5];                                	// enregistre les données du caractere
	


	for(; *str_ptr != '\0'; ++str_ptr, ++x)                 		// Compter jusqu'a la fin du texte
	{

    	if(*str_ptr < 'S') 											// Regarde si le caractere est stocké dans le 1er tableau de caractères (page de 255 bytes)
         	memcpy(pixelData, FONT[*str_ptr - ' '], 5);
	   else if(*str_ptr <= '~') 									// Regarde si le caractere est stocké dans le 2eme tableau de caractères (page de 255 bytes)
         	memcpy(pixelData, FONT2[*str_ptr - 'S'], 5);
	   else
         	memcpy(pixelData, FONT[0], 5);   						// Si caractere non trouvé alors considerer comme espace
			   
      
     
       //sens devant!
     /* for(i=0;i<8;i++)
      {
    	   ledcube [7][i] = 0xFF;//pixelData[0] & (0x01<<i);

      }        */



      /*
	   for(j=0;j<5;j++)  //Pour traiter les 4 bytes provenants de la font
	   {
         
         for(i=0;i<8;i++)	//répéter 8x
         {
            
            if(i<=7) 	//Si le caractère n'est pas encore terminé (en hauteur)
   
       	      ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);    
          	   //ledcube [face_nb][i] |= (pixelData[j] & (0x01<<i))<<(7-(i-j));   
               //ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))<<(i-1); 
         }
      }       */



       




         //////////////////////////
      /*	for(i=0;i<8;i++)  //répéter 8x
         {
            
            if(i<=7) //Si le caractère n'est pas encore terminé (en hauteur)
   
       	      ledcube [face_nb][i] |= (pixelData[0] & (0x80>>i))<<i;        
   
         }    */
         ///////////////////////////////
    //  }

			/*
      	for(i=0;i<8;i++)  //répéter 8x		   0
 		{
   
			ledcube [face_nb][i] |= (pixelData[0] & (0x80>>i))<<i;        
   
      	}  

		for(i=0;i<8;i++)  //répéter 8x		   1
 		{
   			if (i<=1)
			 	ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))>>(1-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[1] & (0x80>>i))<<(i-1);        
   
      	}  
	   	

		for(i=0;i<8;i++)  //répéter 8x		   2
 		{
   			if (i<=2)
			 	ledcube [face_nb][i] |= (pixelData[2] & (0x80>>i))>>(2-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[2] & (0x80>>i))<<(i-2);        
   
      	}  

		for(i=0;i<8;i++)  //répéter 8x		   3
 		{
   			if (i<=3)
			 	ledcube [face_nb][i] |= (pixelData[3] & (0x80>>i))>>(3-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[3] & (0x80>>i))<<(i-3);        
   
      	}  


		for(i=0;i<8;i++)  //répéter 8x		   4
 		{
   			if (i<=4)
			 	ledcube [face_nb][i] |= (pixelData[4] & (0x80>>i))>>(4-i); 
			else 	
				ledcube [face_nb][i] |= (pixelData[4] & (0x80>>i))<<(i-4);        
   
      	}  
			*/


	   	//Code pour afficher le texte sur une face avant du cube
	   	for(j=0;j<5;j++)
		{

		   	for(i=0;i<8;i++)  //répéter 8x		   tout d'un coup
	 		{
	   			if (i<=j)
				 	ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))>>(j-i); 
				else 	
					ledcube [face_nb][i] |= (pixelData[j] & (0x80>>i))<<(i-j);        
	   
	      	}  
	 	}



	 /*  ledcube [0][0] = 0x00;
      ledcube [1][0] = pixelData[0];
      ledcube [2][0] = pixelData[1];
      ledcube [3][0] = pixelData[2];
      ledcube [4][0] = pixelData[3];
      ledcube [5][0] = pixelData[4];
      ledcube [6][0] = 0x00;
      ledcube [7][0] = 0x00;   */    
          
      
	}
}


/*---------------------------------------------------------------------------*-
   rotat_droite()
  -----------------------------------------------------------------------------
   Descriptif: représente le cube avec une rotation de l'image à 90° à droite 
   si sens = 1, ou à gauche si sens = 0.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void rotat_h(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], bit sens)
{
	//=========Déclarations locales============
	xdata unsigned char i,j,k;		
	//=========================================	

	//note: plus de code pour économiser en temps d'exécution!
		   
	if(sens) 	//Si sens pour rotation image à gauche
	{	
		for(i=0;i<8;i++)    //répéter 8x
		{
		   	for(j=0;j<8;j++)		//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x (bit par ligne)		  
	 			{
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | ((ptr_ledcube[k][i]&(1<<j))>>j);    
	   	   		}
	      	}  
	 	}	
	}
	else	  	//Si rotation à droite
	{
	 	for(i=0;i<8;i++)		//répéter 8x	
		{
		   	for(j=0;j<8;j++)  	//répéter 8x		  
	 		{
				for(k=0;k<8;k++)	//répéter 8x (bit par ligne)		 
	 			{
				 //	ptr_newcube [j] [i] =  (ptr_newcube [j][i]<<1) | ((ptr_ledcube[k][i]&(0x80>>j))>>(7-j));
				 	ptr_newcube [j] [i] =  (ptr_newcube [j][i]>>1) | ((ptr_ledcube[k][i]&(0x80>>j))<<j);	    
	   	   		}											  
	      	}  
	 	}		
	}
}


/*---------------------------------------------------------------------------*-
   tabtoface()
  -----------------------------------------------------------------------------
   Descriptif: affiche un tableau sur la face désirée

   Entrée    : (unsigned char) face_nb de 7 à 0. 7 étant la plus proche du front.
   Sortie    : --
-*---------------------------------------------------------------------------*/
void tabtoface(unsigned char ptr_tab[],unsigned char ptr_newcube[][8],unsigned char face_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i;		
	//=========================================	
	
	for (i=0;i<8;i++)    
	{ 					
		ptr_newcube [face_nb][7-i] = ptr_tab [i]; 	
	}    
}







/*---------------------------------------------------------------------------*-
   anim_cligno()
  -----------------------------------------------------------------------------
   Descriptif: l'état du cube est inversé

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
/*void anim_cligno(unsigned char ptr_tab[][8],unsigned char ptr_newcube[][8])
{
	//=========Déclarations locales============
	xdata unsigned char i,j;		
	//=========================================	

	for (i=0;i<8;i++)
	   {   
	     for (j=0;j<8;j++)
	     {
	        ptr_newcube [j][i] = ptr_tab[j][i]^0xFF;    //mise en place de valeur dans le tableau!
	     }
	  }     
	              
	   
}	 		  */

	
/*---------------------------------------------------------------------------*-
   anim_base_up()
  -----------------------------------------------------------------------------
   Descriptif: plateau montant

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up(unsigned char ptr_newcube[][8])
{
	//=========Déclarations locales============
	xdata unsigned char i;
	static xdata unsigned char cpt = 0;		
	//=========================================	

  
   	for (i=0;i<8;i++)
  	{ 
     	ptr_newcube [i][cpt] = 0xFF;    //mise en place de valeur dans le tableau!
     	ptr_newcube [i][(cpt-1)%8] = 0x00;    //mise en place de valeur dans le tableau!
  	}    

  	cpt = (cpt+1)%8;

}
	   
	
/*---------------------------------------------------------------------------*-
   anim_base_up_dn()
  -----------------------------------------------------------------------------
   Descriptif: animation de plaque montante, puis descendante.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_up_dn(unsigned char ptr_newcube[][8])
{
	//=========Déclarations locales============
	xdata unsigned char i;
	static xdata unsigned char cpt = 0;
	static bit sens = 0;		
	//=========================================	

	//sens à 1 pour monter, 0 pour descendre
	  
	for (i=0;i<8;i++)
	{ 
		ptr_newcube [i][cpt] = 0xFF;    //mise en place de valeur dans le tableau!
		if (sens)
	    	ptr_newcube [i][(cpt-1)%8] = 0x00;    //mise en place de valeur dans le tableau!
	  	else
	   		ptr_newcube [i][(cpt+1)%8] = 0x00;    //mise en place de valeur dans le tableau!
	}    
	if(cpt == 7)
	 	sens = 0;
	else if (cpt==0) 
	 	sens = 1;
	
	if (sens)
		cpt++;
	else
	   	cpt--;
	
}	 



/*---------------------------------------------------------------------------*-
   anim_base_l_r()
  -----------------------------------------------------------------------------
   Descriptif: animation de plaque défillante à droite, puis à gauche.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void anim_base_l_r(unsigned char ptr_newcube[][8])
{
	//=========Déclarations locales============
	xdata unsigned char i,j;
	static xdata unsigned char cpt = 0;
	static bit sens = 1;		
	//=========================================	
	
	for (i=0;i<8;i++)          	//répéter 8x
	{ 
		for (j=0;j<8;j++)    	//répéter 8x
		{ 
			if (sens)
	      		ptr_newcube [j] [i] = 0x80>>cpt;	//mise en place de valeur dans le tableau!
	      	else
	      		ptr_newcube [j] [i] = 0x01<<cpt; 	//mise en place de valeur dans le tableau!
	  	}
	}
	
	if(cpt == 7) 	//Inversion du sens à chaque butée atteinte
	{
		sens ^= 1;
		cpt++;
	}  
	cpt = (cpt+1)%8; 	//cpt 0 à 7
	
}						   
						  

/*---------------------------------------------------------------------------*-
   anim_pluie()
  -----------------------------------------------------------------------------
   Descriptif: animation de pluie

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
/*void anim_pluie(unsigned char ptr_newcube[][8],  unsigned char anim_nb)
{
	//=========Déclarations locales============
	xdata unsigned char i,j;
	static xdata unsigned char cpt = 0;		
	//=========================================	

	        
 	switch(anim_nb)
	{
	   	case 1:
		{
			//Scrolling de l'étage supérieur vers inférieur par copie!
				
			for (j=0;j<7;j++) 	//répéter 6x  (de 6 à 0)
			{ 
			   	for (i=0;i<8;i++)          //répéter 8x 
		  		{ 
			     	//Copie du tableau de l'étage supérieur vers l'étage inférieur!
			        ptr_newcube [i][j] = ptr_newcube [i][j+1];    	//Scrolling                   
			          
			  	}
			}
			
			
			for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
			{ 
				ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
			}
		}	
	  	break;	 


		case 2: //============================= pluie cube n°2 ==============================               
	 
	  		for (j=0;j<7;j++) 	//répéter 7x  (de 6 à 0)
	  		{ 
	 	   		for (i=0;i<8;i++)          //répéter 8x 
	  			{ 
	          	   //Copie du tableau de l'étage supérieur vers l'étage inférieur!
	
	         		ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                   
	          
	     		}
	  		}
	
	  		if((cpt%2)==0) //une fois sur deux la pluie sera regénérée
	  		{
		   		for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = rand(); 	//mise en place de valeur dans le tableau! 
	     		}
	  		}
	  		cpt++;
		break;


	   	case 3:
	         
	 	//============================= pluie cube n3 ==============================
	    
			for (j=0;j<7;j++) 	//répéter 6x  (de 6 à 0)
		  	{ 
		 		for (i=0;i<8;i++)          //répéter 8x 
		  		{ 
		          	//Copie du tableau de l'étage supérieur vers l'étage inférieur!
		         	ptr_newcube [i][j] = ptr_newcube [i][j+1];    //Scrolling                   
		       // ledcube [i][j+1] = ledcube [i][j+2];    //Scrolling  
		      //  ledcube [i][j+2] = ledcube [i][j+3];    //Scrolling 
		     	}
		  	}   
	
	
	  		cpt++;
	
	  		if((cpt>=1)&&(cpt<=3))     //une fois sur huit nouvelle pluie sera générée
	  		{
		   		for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = rand();	//mise en place de valeur dans le tableau! 
	     		}
	  		}
		  	else if (cpt >= 8)
		  	{
		     	cpt = 0;  	
		  	}
	  		else
	  		{
	     		for (j=0;j<8;j++) 	//répéter 8x  (pour générer la pluie aléatoire sur le 1er étage)
	     		{ 
	        		ptr_newcube [j][7] = 0x00;	//premier étage éteint
	     		}
	  		}
			break;	
	}
}	  	*/   

/*---------------------------------------------------------------------------*-
   copy_cube()
  -----------------------------------------------------------------------------
   Descriptif: copie un tableau source 2D dans un tableau dest 2D 

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void copy_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab_dst[j][i] = tab_src[j][i];	//copie des bytes			 	
		}	
	}	
}


/*---------------------------------------------------------------------------*-
   copy_cube()
  -----------------------------------------------------------------------------
   Descriptif: n'allume que les points à 1 du tableau source dans celui 
   de destination.

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void or_cube(unsigned char tab_src[][8],unsigned char tab_dst[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab_dst[j][i] |= tab_src[j][i];		//OR des bytes			 	
		}	
	}	
}

/*---------------------------------------------------------------------------*-
   clear_cube()
  -----------------------------------------------------------------------------
   Descriptif: éteint un cube. (mise à 0 de toutes les variable du tableau).

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void clear_cube(unsigned char tab[][8])
{
 	//=========Déclarations locales============
 	xdata unsigned char i,j;
	//=========================================

	for(i=0;i<8;i++)		  	//64x
	{
		for(j=0;j<8;j++)
		{
			tab[j][i] = 0x00;	//mise à 0 des bytes			 	
		}	
	}	
}



/*---------------------------------------------------------------------------*-
   wr_coord_cube()
  -----------------------------------------------------------------------------
   Descriptif: met dans l'état désiré le bit correspondant à la led choisie 
   dans un tableau "de cube".

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
/*void wr_coord_cube(char x,char y,char z,bit state,unsigned char ptr_tab[][8])
{
	if(x&&y&&z&&(x<5)&&(y<5)&&(z<5)&&(x>-5)&&(y>-5)&&(z>-5))	//Si le point n'est pas sur un axe (0) et qu'il est situé dans l'espace du cube
	{
		x = (x>0)? 4-x:3-x;
		y = (y>0)? y+3:y+4;
		z = (z>0)? 4-z:3-z;		

		ptr_tab[z][y] = ((state)?0xFF:0x00)&(0x01<<x);
	}
}  	 */ 



/*---------------------------------------------------------------------------*-
   rotat_v()
  -----------------------------------------------------------------------------
   Descriptif: 

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
/*void rotat_v(unsigned char ptr_ledcube[][8],unsigned char ptr_newcube[][8], bit sens)
{
	//=========Déclarations locales============
	xdata unsigned char i,j,k;		
	//=========================================	
  	



}	   */
	 
	 
/*---------------------------------------------------------------------------*-
   luminosite()
  -----------------------------------------------------------------------------
   Descriptif: un paramètre de 0 à 100 est passé afin de définir la valeur du PWM
	100 = luminosité max, 0 = éteint! 

   Entrée    : --
   Sortie    : --
-*---------------------------------------------------------------------------*/
void luminosite(unsigned char lum)
{  	
	pwm_prechg = ((unsigned int)lum*255/100);	//conversion du % en 
															//valeur de préchargement PWM
}	   
	 


/*---------------------------------------------------------------------------*-
Init_Timer0()
-----------------------------------------------------------------------------
Descriptif: Initialisation du timer0 avec incrémentation toutes les 2 [us].
Entrée : --
Sortie : --
-*---------------------------------------------------------------------------*/
void Init_Timer0()
{			
	
	TR0 = 0; 	//Stop le timer
	ET0 = 0; 	//Inhibe l'interruption du timer
	//--- Mode de fonctionnement du timer 0

	TMOD &= 0xF0;		// 		reset initialisation timer 0
				  	   	//     +----- Pas de gate externe
				  	   	//     |+---- Fonction Temporisation
				  	   	// 	 ||++-- Mode 1 16 bits
				  			// 	 ||||
	TMOD |= 0x01;   	// xxxx0010

	CKCON &= ~0x07;   	// clear des bits pour config prescaler

                   	//         +---- Prédiviseur activé 								
                   	//         |++-- Système clock / 48 donc incréments 
                   	//         ||| 							toutes les 1 us.
	CKCON |= 0x02;  	// 	xxxx0010  
	
	TL0 = TIMER0_LOAD/256; 	
	TH0 = TIMER0_LOAD%256;	//Charge la valeur initiale 
	   
	
	TF0 = 0; //Clear une interruption résiduelle
	ET0 = 1; // Autorise l'interruption du timer 0

} // Init_Timer0 --------------------------------------------------------------


/*---------------------------------------------------------------------------*-
  cmp_ss_chaine ()
  -----------------------------------------------------------------------------
   Descriptif: compare dès le début de la chaine avec la sous-chaine 
   Entrée    : --
				  
   Sortie    : le bit indiquant que la sous chaine est bien le commencement de la chaine 
   (à 1 si similitude)
-*---------------------------------------------------------------------------*/
bit Cmp_ss_chaine (char ss_chaine [], char chaine [])
{	
	/**************Déclarations locales***************/
  	bit similitude = 1;
	unsigned char i = 0;
	/*************************************************/

	while ((ss_chaine [i]) && (similitude))	//tant qu'un caractère est présent dans la sous-chaine imposée et qu'il n'y a pas d'erreur
	{
		if (ss_chaine [i] != chaine [i])			//Si les caractères sont différents,
		{
			similitude = 0; 							//il y a une érreur...
		}
		i++;												//Incrémentation de i
	}
	return similitude;	//retour du bit  	
}	//Cmp_ss_chaine============================================================
